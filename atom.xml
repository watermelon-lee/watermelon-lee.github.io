<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watermelon</title>
  
  <subtitle>远远和元老大的小窝</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-21T14:32:28.593Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>watermelon-lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring-ORM</title>
    <link href="http://yoursite.com/2018/04/21/Spring-ORM/"/>
    <id>http://yoursite.com/2018/04/21/Spring-ORM/</id>
    <published>2018-04-21T14:32:28.000Z</published>
    <updated>2018-04-21T14:32:28.593Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring-JDBC</title>
    <link href="http://yoursite.com/2018/04/17/Spring-JDBC/"/>
    <id>http://yoursite.com/2018/04/17/Spring-JDBC/</id>
    <published>2018-04-17T14:09:29.000Z</published>
    <updated>2018-04-22T02:28:02.755Z</updated>
    
    <content type="html"><![CDATA[<p>Spring JDBC是Spring所提供的持久层技术.在Spring JDBC里面只需要做那些与业务相关的事情DML操作,而将资源获取,statement创建,资源释放,异常处理的等繁杂的工作交给Spring JDBC.<br><a id="more"></a></p><h1 id="使用Spring-JDBC访问数据库"><a href="#使用Spring-JDBC访问数据库" class="headerlink" title="使用Spring JDBC访问数据库"></a>使用Spring JDBC访问数据库</h1><h2 id="JdbcTemplate尝试"><a href="#JdbcTemplate尝试" class="headerlink" title="JdbcTemplate尝试"></a>JdbcTemplate尝试</h2><p>在使用JSP/servlet时,使用JDBC连接数据库需要自己手动获取JDBC连接,处理异常,关闭连接等.而使用Spring JDBC通过模板与回调机制降低了使用JDBC的复杂性,借助JdbcTemplate,只需要一些”必不可少”的步骤就可以操作数据库.<br>代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DriverManagerDataSource ds=new DriverManagerDataSource();</span><br><span class="line">        ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        ds.setUrl(&quot;jdbc:mysql://localhost:3306/sampledb&quot;);</span><br><span class="line">        ds.setUsername(&quot;root&quot;);</span><br><span class="line">        ds.setPassword(&quot;19970901&quot;);</span><br><span class="line">        </span><br><span class="line">        JdbcTemplate jdbcTemplate=new JdbcTemplate();</span><br><span class="line">        jdbcTemplate.setDataSource(ds);</span><br><span class="line">        </span><br><span class="line">        String sql=&quot;create table user(user_id int primary key,user_name varchar(60))&quot;;</span><br><span class="line">        jdbcTemplate.execute(sql);</span><br></pre></td></tr></table></figure></p><h2 id="在dao中使用JdbcTemplate"><a href="#在dao中使用JdbcTemplate" class="headerlink" title="在dao中使用JdbcTemplate"></a>在dao中使用JdbcTemplate</h2><p>在Dao类中可以直接使用JdbcTemplate,在XML文件中配置好后,直接在DAO中注入即可.<br>DAO类代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ForumDao &#123;</span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired//自动注入JdbcTemplate实例</span><br><span class="line">    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;</span><br><span class="line">        this.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //创建表格</span><br><span class="line">    public void initDb() &#123;</span><br><span class="line">        //在实际项目中,sql如果不是动态组装,需要将其定义为类级final常量</span><br><span class="line">        String sql = &quot;create table t_user(user_id int primary key,user_name varchar(60))&quot;;</span><br><span class="line">        jdbcTemplate.execute(sql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>XML配置文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--扫描包以注册申明的bean--&gt;</span><br><span class="line">  &lt;context:component-scan base-package=&quot;com.dao&quot;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 配置数据源--&gt;</span><br><span class="line">  &lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt;</span><br><span class="line">  &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span><br><span class="line">        destroy-method=&quot;close&quot;</span><br><span class="line">        p:driverClassName=&quot;$&#123;jdbc.driverClassName&#125;&quot;</span><br><span class="line">        p:url=&quot;$&#123;jdbc.url&#125;&quot;</span><br><span class="line">        p:username=&quot;$&#123;jdbc.username&#125;&quot;</span><br><span class="line">        p:password=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">  &lt;!--声明Jdbcemplate Bean--&gt;</span><br><span class="line">  &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot; p:dataSource-ref=&quot;dataSource&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>在Spring配置文件中,配置DAO一般有4个步骤:</p><ol><li>定义DataSource  </li><li>定义JdbcTemplate  </li><li>声明一个抽象的Bean,以便所有的Dao复用配置JdbcTamplate配置的属性  </li><li>配置具体的Dao</li></ol><h2 id="基本数据库操作"><a href="#基本数据库操作" class="headerlink" title="基本数据库操作"></a>基本数据库操作</h2><h3 id="更改数据"><a href="#更改数据" class="headerlink" title="更改数据"></a>更改数据</h3><p>JdbcTemplate提供了若干个Update()方法,来对数据表进行更改和删除<br>代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//更改数据</span><br><span class="line">    public  void addForum(Forum forum) &#123;</span><br><span class="line">        String sql = &quot;insert into t_forum(forum_name,forum_desc) values(?,?)&quot;;</span><br><span class="line">        Object[] params = &#123;forum.getForumName(), forum.getForumDesc()&#125;;</span><br><span class="line">        //jdbcTemplate.update(sql,params);</span><br><span class="line">        jdbcTemplate.update(sql, params, new int[]&#123;Types.VARCHAR, Types.VARCHAR&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>JdbcTemplate在内部使用PreparedStatement执行SQL语句,可以使用绑定参数的SQL语句,使用占位符?.用Object[]args数组来定义填充占位符的参数,使用JdbcTemplate的int update(String sql,Object[] args,int[] argsTypes),int[] argsTypes数组来显式制定每个占位符对应的数据类型,以保证类型的安全.</p><h3 id="返回数据库表自增的主键"><a href="#返回数据库表自增的主键" class="headerlink" title="返回数据库表自增的主键"></a>返回数据库表自增的主键</h3><p>在开发时,我们有时候使用数据库自增字段为表的主键,主键不在应用层产生,而是在新增数据记录时产生.这样在应用层保存对象前我们不知道对象的主键值,在JDBC中,允许将数据库主键值绑定到Statement或者PrepareStatement上,利用这个技术,Spring提供了一个可以返回新增记录主键值的方法:<code>int update(PrepareStatementCreator osc,KeyHolder generatedKeyHolder)</code>.<br>代码如下:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">       在t_forum中使用了自增主键,则主键值不会再应用层,需要我们自己获取.</span><br><span class="line">       Spring jdbc3.0添加可回去住建的KeyHolder接口,通用实现类为GeneratedKeyHolder</span><br><span class="line">        */</span><br><span class="line">   public void addForumAndGetMainValue(final Forum forum)&#123;</span><br><span class="line"></span><br><span class="line">   KeyHolder keyHolder = new GeneratedKeyHolder();//创建一个主键持有者</span><br><span class="line">       final String  sql = &quot;insert into t_forum(forum_name,forum_desc) values(?,?)&quot;;</span><br><span class="line">       jdbcTemplate.update(new PreparedStatementCreator() &#123;</span><br><span class="line">       public PreparedStatement createPreparedStatement (Connection connection) throws SQLException &#123;</span><br><span class="line">           PreparedStatement preparedStatement=connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">           preparedStatement.setString(1,forum.getForumName());</span><br><span class="line">           preparedStatement.setString(2,forum.getForumDesc());</span><br><span class="line">           return  preparedStatement;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,keyHolder);</span><br><span class="line">       forum.setForumId(keyHolder.getKey().intValue());//从主键持有者中获取主键</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这样在调用addForum后新增forum领域对象后,forum将拥有对应的主键,方便以后使用.</p><h3 id="批量更改数据"><a href="#批量更改数据" class="headerlink" title="批量更改数据"></a>批量更改数据</h3><p>JdbcTemplate有两个批量操作数据的方法:  </p><ul><li>public int[] batchUpdate(String[] sql):多条sql语句组成一个数组,这些sql语句不带参数,该方法以批量方式执行这些操作.</li><li>int[] batchUpdate(String sql,BatchPrepareStatementSetter pss):该方法对于同一结构带参SQL语句多次进行数据更新.通过BatchPrepareStatementSetter回调接口进行批量绑定参数.BatchPrepareStatementSetter定义了两个方法:<ol><li>int getBatchSize():指定本批次的大小</li><li>void setValues(PrepareStatement ps,int i):为给定的PrepareStatement指定参数.</li></ol></li></ul><p>加入论坛一次性新增多个板块,可如下编写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 批量更改</span><br><span class="line">  public void addForums(final List&lt;Forum&gt; forums)&#123;</span><br><span class="line">      final String sql=&quot;insert into t_forum(forum_name,forum_desc) values(?,?)&quot;;</span><br><span class="line"></span><br><span class="line">      jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() &#123;</span><br><span class="line">          public void setValues(PreparedStatement preparedStatement, int i) throws SQLException &#123;</span><br><span class="line">              Forum forum=forums.get(i);</span><br><span class="line">              preparedStatement.setString(1,forum.getForumName());</span><br><span class="line">              preparedStatement.setString(2,forum.getForumDesc());</span><br><span class="line">          &#125;</span><br><span class="line">          //指定该批记录的记录数</span><br><span class="line">          public int getBatchSize() &#123;</span><br><span class="line">              return forums.size();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      addForum(forums.get(10));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><h4 id="使用RowCallbackHandler"><a href="#使用RowCallbackHandler" class="headerlink" title="使用RowCallbackHandler"></a>使用RowCallbackHandler</h4><p>RowCallbackHandler接口与很简单,只有一个方法:`void processRow(ResultSet rs) throws SQLException.<br>ForumDao需要提供一个根据forumId来获取Forum对象的方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> // 单次查询数据</span><br><span class="line">    public Forum getForum(final int id)&#123;</span><br><span class="line">        final String sql=&quot;select forum_name,forum_desc from t_forum where forum_id=?&quot;;</span><br><span class="line">        final Forum forum=new Forum();</span><br><span class="line">        jdbcTemplate.query(sql, new Object[]&#123;id&#125;, new RowCallbackHandler() &#123;</span><br><span class="line">            public void processRow(ResultSet resultSet) throws SQLException &#123;</span><br><span class="line">                forum.setForumId(id);</span><br><span class="line">                forum.setForumName(resultSet.getString(&quot;forum_name&quot;));</span><br><span class="line">                forum.setForumDesc(resultSet.getString(&quot;forum_desc&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return forum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//批量查询</span><br><span class="line">    public List&lt;Forum&gt; getForums(final int id,final int toId)&#123;</span><br><span class="line">        String sql=&quot;select forum_name,forum_desc form t_forum where forum_id between ? and ?&quot;;</span><br><span class="line">        final List&lt;Forum&gt; forums=new ArrayList&lt;Forum&gt;();</span><br><span class="line"></span><br><span class="line">        jdbcTemplate.query(sql, new Object[]&#123;id, toId&#125;, new RowCallbackHandler() &#123;</span><br><span class="line">            public void processRow(ResultSet resultSet) throws SQLException &#123;</span><br><span class="line">                Forum forum=new Forum();</span><br><span class="line">                forum.setForumId(resultSet.getInt(&quot;forum_id&quot;));</span><br><span class="line">                forum.setForumName(resultSet.getString(&quot;forum_name&quot;));</span><br><span class="line">                forum.setForumDesc(resultSet.getString(&quot;forum_desc&quot;));</span><br><span class="line">                forums.add(forum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return forums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用RowMapper"><a href="#使用RowMapper" class="headerlink" title="使用RowMapper"></a>使用RowMapper<t></t></h4><p>RowMapper<t>接口只有一个方法:T mapRow(ResultSet rs,int rowNum).JJdbcTemplate提供了许多个使用RowMapper<t>的查询方法,这些方法返回List.下面使用JdbcTemplate的List query(String sql,Object[] args,RowMapper<t> rowMapper)方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Forum&gt; getForums(final int fromId, final int toId) &#123;</span><br><span class="line">String sql = &quot;SELECT forum_id,forum_name,forum_desc FROM t_forum WHERE forum_id between ? and ?&quot;;</span><br><span class="line">// 方法1：使用RowCallbackHandler接口</span><br><span class="line">/*</span><br><span class="line"> * final List&lt;Forum&gt; forums = new ArrayList&lt;Forum&gt;();</span><br><span class="line"> * jdbcTemplate.query(sql,new Object[]&#123;fromId,toId&#125;,new</span><br><span class="line"> * RowCallbackHandler()&#123; public void processRow(ResultSet rs) throws</span><br><span class="line"> * SQLException &#123; Forum forum = new Forum();</span><br><span class="line"> * forum.setForumId(rs.getInt(&quot;forum_id&quot;));</span><br><span class="line"> * forum.setForumName(rs.getString(&quot;forum_name&quot;));</span><br><span class="line"> * forum.setForumDesc(rs.getString(&quot;forum_desc&quot;)); forums.add(forum);</span><br><span class="line"> * &#125;&#125;); return forums;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">return jdbcTemplate.query(sql, new Object[] &#123; fromId, toId &#125;,</span><br><span class="line">new RowMapper&lt;Forum&gt;() &#123;</span><br><span class="line">public Forum mapRow(ResultSet rs, int index)</span><br><span class="line">throws SQLException &#123;</span><br><span class="line">Forum forum = new Forum();</span><br><span class="line">forum.setForumId(rs.getInt(&quot;forum_id&quot;));</span><br><span class="line">forum.setForumName(rs.getString(&quot;forum_name&quot;));</span><br><span class="line">forum.setForumDesc(rs.getString(&quot;forum_desc&quot;));</span><br><span class="line">return forum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></t></p><p>可以看到使用RowCallbackHandler的void processRow(ResultSet rs)方法,需要自己将行数据映射到对象Forum手动添加的外部定义forums列表中,而RowMapper<t>的 T mapROw(ResultSet rs,int index)方法中,只需要简单的定义结果集和对象的映射关系,创建List,映射对象添加到List都有JdbcTemplate完成.</t></p><h4 id="RowCallbackHandler与RowMapper区别"><a href="#RowCallbackHandler与RowMapper区别" class="headerlink" title="RowCallbackHandler与RowMapper区别"></a>RowCallbackHandler与RowMapper区别</h4><p>可以看到使用RowCallbackHandler的void processRow(ResultSet rs)方法,需要自己将行数据映射到对象Forum手动添加的外部定义forums列表中,而RowMapper<t>的 T mapROw(ResultSet rs,int index)方法中,只需要简单的定义结果集和对象的映射关系,创建List,映射对象添加到List都有JdbcTemplate完成.<br>当处理大结果数据集时,使用RowMapper,采用的方式是将所有的数据集放到一个List<t>对象中,这样将占用JVM大量内存,而使用RowCallbackHandler()的 public void processRow(ResultSet resultSet)将会一边获取数据,一边完成处理,这样数据不会大量堆积在JVM中,造成大量内存占用.  </t></t></p><h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Repository(value = &quot;topic&quot;)</span><br><span class="line">public class TopicDao &#123;</span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;</span><br><span class="line">        this.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    //调用存储过程</span><br><span class="line">    /*存储过程如下:</span><br><span class="line">    CREATE PROCEDURE P_GET_TOPIC_NUM(IN in_user_id INT,OUT out_num INT)</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT COUNT(*) INTO out_num  FROM t_topic WHERE user_id = in_user_id;</span><br><span class="line">END</span><br><span class="line">     */</span><br><span class="line">    public int getUserTopicNum(final int userId)&#123;</span><br><span class="line">        String sql=&quot;&#123;call P_GET_TOPIC_NUM(?,?)&#125;&quot;;</span><br><span class="line">        Integer num=jdbcTemplate.execute(sql, new CallableStatementCallback&lt;Integer&gt;() &#123;</span><br><span class="line">            public Integer doInCallableStatement(CallableStatement callableStatement) throws SQLException, DataAccessException &#123;</span><br><span class="line">                callableStatement.setInt(1,userId);//绑定入参</span><br><span class="line">                callableStatement.registerOutParameter(2, Types.INTEGER);//注册输出参数</span><br><span class="line">                callableStatement.execute();//执行</span><br><span class="line">                return callableStatement.getInt(2);//获取输出参数值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BLOB-CLOB类型数据操作"><a href="#BLOB-CLOB类型数据操作" class="headerlink" title="BLOB/ CLOB类型数据操作"></a>BLOB/ CLOB类型数据操作</h2><p>前面使用了JdbcTemplate的CRUD(create retrieve Update delete),现在了解如何对BLOB/ CLOB类型进行数据操作<br>LOB代表大对象数据,包括BLOB和CLOB.前者用于存储大块的二进制数据,如图片,视频(一般不宜存到数据库中,存至文件服务器中),后者存储长文本数据,如论坛帖子,产品详细描述.</p><h3 id="LobCreator"><a href="#LobCreator" class="headerlink" title="LobCreator"></a>LobCreator</h3><p>为了方便在 PreparedStatement 中使用 LobCreator，可以直接使用 JdbcTemplate#execute(String sql,AbstractLobCreatingPreparedStatementCallback lcpsc) 方法。下面对 LobCreator 接口中的方法进行简要说明：</p><ul><li>void close():关闭会话，并释放 LOB 资源</li><li>void setBlobAsBinaryStream(PreparedStatement ps, int paramIndex, InputStream contentStream, int contentLength) :通过流填充 BLOB 数据</li><li>void setBlobAsBytes(PreparedStatement ps, int paramIndex, byte[] content): 通过二进制数据填充 BLOB 数据</li><li>void setClobAsAsciiStream(PreparedStatement ps, int paramIndex, InputStream asciiStream, int contentLength): 通过 Ascii 字符流填充 CLOB 数据</li><li>void setClobAsCharacterStream(PreparedStatement ps, int paramIndex, Reader characterStream, int contentLength) :通过 Unicode 字符流填充 CLOB 数据</li><li>void setClobAsString(PreparedStatement ps, int paramIndex, String content):</li></ul><h3 id="LobHandler"><a href="#LobHandler" class="headerlink" title="LobHandler"></a>LobHandler</h3><p>LobHandler 接口为操作 BLOB/CLOB 提供了统一访问接口，而不管底层数据库究竟是以大对象的方式还是以一般数据类型的方式进行操作。此外，LobHandler 还充当了 LobCreator 的工厂类。实现类使用DefualtLobHandler.看一下 LobHandler 接口的几个重要方法：  </p><ul><li>InputStream getBlobAsBinaryStream(ResultSet rs, int columnIndex)    从结果集中返回 InputStream，通过 InputStream 读取 BLOB 数据</li><li>byte[] getBlobAsBytes(ResultSet rs, int columnIndex)    以二进制数据的方式获取结果集中的 BLOB 数据；</li><li>InputStream getClobAsAsciiStream(ResultSet rs, int columnIndex)    从结果集中返回 InputStream，通过 <em> </em> InputStreamn 以 Ascii 字符流方式读取 BLOB 数据</li><li>Reader getClobAsCharacterStream(ResultSet rs, int columnIndex)    从结果集中获取 Unicode 字符流 Reader，并通过 Reader以Unicode 字符流方式读取 CLOB 数据</li><li>String getClobAsString(ResultSet rs, int columnIndex)    从结果集中以字符串的方式获取 CLOB 数据</li><li>LobCreator getLobCreator()    生成一个会话相关的 LobCreator 对象</li></ul><h3 id="插入LOB类型数据"><a href="#插入LOB类型数据" class="headerlink" title="插入LOB类型数据"></a>插入LOB类型数据</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void addPost(final Post post)&#123;</span><br><span class="line">      String sql=&quot;insert into t_post(post_id,user_id,post_text,post_attach) values(?,?,?,?)&quot;;</span><br><span class="line">      jdbcTemplate.execute(sql, new AbstractLobCreatingPreparedStatementCallback(this.lobHandler) &#123;</span><br><span class="line">          @Override</span><br><span class="line">          protected void setValues(PreparedStatement preparedStatement, LobCreator lobCreator) throws SQLException, DataAccessException &#123;</span><br><span class="line">             // preparedStatement.setInt(1,1);</span><br><span class="line">              preparedStatement.setInt(1,incrementer.nextIntValue());//获取下一个主键值</span><br><span class="line">              preparedStatement.setInt(2,post.getUserId());</span><br><span class="line"></span><br><span class="line">              //设置CLOB字段</span><br><span class="line">              lobCreator.setClobAsString(preparedStatement,3,post.getPostText());</span><br><span class="line"></span><br><span class="line">              //设置BLOB字段</span><br><span class="line">              lobCreator.setBlobAsBytes(preparedStatement,4,post.getPostAttach());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>在PostDao中引入一个LobHandler属性,通过<code>jdbcTemplate.execute(sql,  AbstractLobCreatingPreparedStatementCallback lcpsc)</code>方法插入LOB数据,然后通过匿名内部类方式定义LobCreatingPreparedStatementCallback的抽象子类,其构造函数需要一个LobHandler的入参,最后在匿名内部类中实现父类抽象方法setValues(PrepareStatement ps,LobCreator lobCreator),在该方法中通过lOBCreator操作LOB对象,分别通过字符串,二进制数组填充BLOB和CLOB.<br>使用MySQL数据库,我们可以在配置文件中如下配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;lobHandler&quot; class=&quot;org.springframework.jdbc.support.lob.DefaultLobHandler&quot; lazy-init=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure></p><h3 id="以块数据方式读取LOB数据"><a href="#以块数据方式读取LOB数据" class="headerlink" title="以块数据方式读取LOB数据"></a>以块数据方式读取LOB数据</h3><p>可以直接以数据块方式读取LOB数据:以String读取CLOB数据,以byte[]读取BLOB数据.<br>代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public List getAttachs(final int userId)&#123;</span><br><span class="line">        String sql=&quot;select post_id,post_attachs from t_user where user_id=? and post_attach is not null&quot;;</span><br><span class="line">        return jdbcTemplate.query(sql, new Object[]&#123;userId&#125;, new RowMapper() &#123;</span><br><span class="line">            public Object mapRow(ResultSet resultSet, int i) throws SQLException &#123;</span><br><span class="line">                int postId=resultSet.getInt(1);</span><br><span class="line">                 // 以二进制的方式获取BLOB数据</span><br><span class="line">                byte[] attach=lobHandler.getBlobAsBytes(resultSet,2);</span><br><span class="line">                Post post=new Post();</span><br><span class="line">                post.setPostId(postId);</span><br><span class="line">                post.setPostAttach(attach);</span><br><span class="line">                return post;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>通过JdbcTemplate的List<t>query(String sql,Object[] args,RowMapper rowMapper)接口处理行数据的映射.在ROwMapper回调的mapRow()接口方法中,通过LOBHandler以byte[]获取BLOB数据.</t></p><h2 id="自增键"><a href="#自增键" class="headerlink" title="自增键"></a>自增键</h2><p>数据库都会提供自增键,如MySQL的auto_increment,Spring允许在应用层产生主键,需要使用DataFieldMaxValueIncrementer接口<br>代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private DataFieldMaxValueIncrementer incrementer;//主键值产生器</span><br><span class="line"></span><br><span class="line">   @Autowired</span><br><span class="line">   public void setIncrementer(DataFieldMaxValueIncrementer incrementer)&#123;</span><br><span class="line">       this.incrementer=incrementer;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void addPost(final Post post)&#123;</span><br><span class="line">       String sql=&quot;insert into t_post(post_id,user_id,post_text,post_attach) values(?,?,?,?)&quot;;</span><br><span class="line">       jdbcTemplate.execute(sql, new AbstractLobCreatingPreparedStatementCallback(this.lobHandler) &#123;</span><br><span class="line">           @Override</span><br><span class="line">           protected void setValues(PreparedStatement preparedStatement, LobCreator lobCreator) throws SQLException, DataAccessException &#123;</span><br><span class="line">              // preparedStatement.setInt(1,1);</span><br><span class="line">               preparedStatement.setInt(1,incrementer.nextIntValue());//获取下一个主键值</span><br><span class="line">               preparedStatement.setInt(2,post.getUserId());</span><br><span class="line"></span><br><span class="line">               //设置CLOB字段</span><br><span class="line">               lobCreator.setClobAsString(preparedStatement,3,post.getPostText());</span><br><span class="line"></span><br><span class="line">               //设置BLOB字段</span><br><span class="line">               lobCreator.setBlobAsBytes(preparedStatement,4,post.getPostAttach());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>在MySql中创建一张用于维护他_post主键的他_post_id表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">   sequence_id  int</span><br><span class="line">)</span><br><span class="line"> ENGINE = MYISAM;</span><br><span class="line"> insert into t_post_id values(0);</span><br></pre></td></tr></table></figure></p><p>主键维护表的并发访问量很大,最好将其声明为<a href="https://blog.csdn.net/hu2010shuai/article/details/54907363" target="_blank" rel="noopener">MYISAM</a>类型,此外,需要为该表提供初始值,一边后续主建值在上面递增.<br>在Spirng配置文件中需要如下配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;increment&quot; class=&quot;org.springframework.jdbc.support.incrementer.MySQLMaxValueIncrementer&quot;</span><br><span class="line">          p:incrementerName=&quot;t_post_id&quot;</span><br><span class="line">          p:columnName=&quot;sequence_id&quot;</span><br><span class="line">          p:cacheSize=&quot;1&quot;</span><br><span class="line">          p:dataSource-ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;!-- 属性依次为 维护主键的表名,用于生成主键值的列名,缓存大小--&gt;</span><br></pre></td></tr></table></figure></p><p>CacheSize决定一次返回的主键数,这里设置为10,第一次获取主键后,他_post_id中的Sequence_id递增10,然后后面9次都在在缓存中获取,之后在返回他_post_id获取.  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring JDBC是Spring所提供的持久层技术.在Spring JDBC里面只需要做那些与业务相关的事情DML操作,而将资源获取,statement创建,资源释放,异常处理的等繁杂的工作交给Spring JDBC.&lt;br&gt;
    
    </summary>
    
      <category term="study" scheme="http://yoursite.com/categories/study/"/>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>西瓜健身计划</title>
    <link href="http://yoursite.com/2018/04/17/fitness-plan/"/>
    <id>http://yoursite.com/2018/04/17/fitness-plan/</id>
    <published>2018-04-17T06:11:20.000Z</published>
    <updated>2018-04-18T01:35:49.453Z</updated>
    
    <content type="html"><![CDATA[<p>远远去健身房办卡啦,她有点害羞,不知道做什么好,给远远一份健身计划~<br><a id="more"></a></p><h1 id="one-臀腿"><a href="#one-臀腿" class="headerlink" title="one 臀腿"></a>one 臀腿</h1><h2 id="臀桥"><a href="#臀桥" class="headerlink" title="臀桥"></a>臀桥</h2><p><img src="../../../../img/fitness/1.jpg" alt="臀桥"><br>要点:</p><ul><li>仰卧,屈膝,双脚与肩膀同宽,脚跟支撑地面(脚掌支持地面容易借力,影响臀部发力)</li><li>向上发力臀收紧,身体呈一条直线</li><li>在顶端停止一秒,慢慢落下.</li><li>3*15</li></ul><h2 id="跪姿后抬腿"><a href="#跪姿后抬腿" class="headerlink" title="跪姿后抬腿"></a>跪姿后抬腿</h2><p><img src="../../../../img/fitness/2.jpg" alt="跪姿后抬腿"><br>要点:</p><ul><li>双手与肩同宽,手臂与地面垂直,双膝与髋同宽</li><li>腿向后发力,顶部静止一秒</li><li>6*10(左右腿分别做组,每边3组,交替做组)</li></ul><h2 id="哑铃箭步蹲"><a href="#哑铃箭步蹲" class="headerlink" title="哑铃箭步蹲"></a>哑铃箭步蹲</h2><p><img src="../../../../img/fitness/3.jpg" alt="哑铃箭步蹲"><br>要点:</p><ul><li>一腿在前,一腿在后,重心位于两腿中间</li><li>双手握哑铃,拳心相对</li><li>同时弯曲两个膝关节,蹲至前侧大腿与身体程90度,后侧大腿与小腿90度,下蹲最后稍微停顿,前面的脚后跟发力站起到起始动作</li><li>6*10(左右腿分别做组,每边3组,交替做组)</li></ul><h2 id="深蹲"><a href="#深蹲" class="headerlink" title="深蹲"></a>深蹲</h2><p><img src="../../../../img/fitness/4.jpg" alt="深蹲"><br>要点:</p><ul><li>双脚与肩同宽,脚尖与膝盖朝向一致</li><li>背部下蹲时不应过于前倾,停止腰背,膝盖不超过脚尖,下蹲至大腿与地面平行</li><li>3*10(瑜伽房里面有小杠铃杆,自己可以自由加哑铃片,适量即可,也可以自己拿小哑铃握在胸前深蹲)</li></ul><h2 id="跑步-单车"><a href="#跑步-单车" class="headerlink" title="跑步||单车"></a>跑步||单车</h2><p>要点:</p><ul><li>走跑交替可达到更好的效果,对膝盖的磨损也更小,可以坡度走10分钟,然后平跑15分钟,在最后平走5分钟(跑步机上分为速度档和坡度当哦)</li><li>蹬单车30分钟,可以自己加大扭矩进行爬坡(站着骑),中等扭矩长距离骑行,较小扭矩冲刺训练</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上均为臀部,腿部运动,并且有不小的训练量,也可减脂,锻炼完记得要充分拉伸按摩,不然容易第二天起来酸痛</p><h1 id="上肢"><a href="#上肢" class="headerlink" title="上肢"></a>上肢</h1><h2 id="开和跳"><a href="#开和跳" class="headerlink" title="开和跳"></a>开和跳</h2><p><img src="../../../../img/fitness/5.jpg" alt="开和跳"><br>要点:</p><ul><li>头部平视,收紧腰腹</li><li>3*30s</li></ul><h2 id="哑铃平举"><a href="#哑铃平举" class="headerlink" title="哑铃平举"></a>哑铃平举</h2><p><img src="../../../../img/fitness/6.jpg" alt="哑铃平举"><br>要点:</p><ul><li>自然站立,挺胸收腹,双手握住哑铃放在大腿前册</li><li>绷紧手臂,以关节为轴,举起至肘关节与肩膀同高,拳心向下</li><li>6*10(用2kg或3kg的哑铃即可,3组侧平举,3组前平举)</li></ul><h2 id="哑铃交替弯举"><a href="#哑铃交替弯举" class="headerlink" title="哑铃交替弯举"></a>哑铃交替弯举</h2><p><img src="../../../../img/fitness/7.jpg" alt="哑铃交替弯举"><br>要点:</p><ul><li>双脚与肩同宽,掌心朝向身体握住哑铃,放在身体两侧,哑铃与身体垂直.</li><li>弯举时,上臂固定夹紧,手臂外旋同时举起哑铃,弯举至最高时,哑铃与身体平行</li><li>3*12</li></ul><h2 id="哑铃划船"><a href="#哑铃划船" class="headerlink" title="哑铃划船"></a>哑铃划船</h2><p><img src="../../../../img/fitness/8.jpg" alt="哑铃划船"><br>要点:</p><ul><li>背部挺直,躯干与地面30度,屈膝,拳心朝前,手臂自然下垂</li><li>屈肘,将小哑铃向后拉,在动作顶部收缩背部,停顿1s,然后慢慢返回</li><li>3*15<h1 id="腹部"><a href="#腹部" class="headerlink" title="腹部"></a>腹部</h1><h2 id="单腿屈膝两头起"><a href="#单腿屈膝两头起" class="headerlink" title="单腿屈膝两头起"></a>单腿屈膝两头起</h2><img src="../../../../img/fitness/9.jpg" alt="单腿屈膝两头起"><br>要点:</li><li>屈膝躺在垫子上,手臂向上伸直</li><li>提膝至小腿平行地面</li><li>卷腹时双手用力向前伸</li><li>3*12(左右脚一边一次,总共每边6次)</li></ul><h2 id="屈膝收腹"><a href="#屈膝收腹" class="headerlink" title="屈膝收腹"></a>屈膝收腹</h2><p><img src="../../../../img/fitness/10.jpg" alt="屈膝收腹"><br>要点:</p><ul><li>后仰坐在地上,臀部着地,手臂后伸撑地,双腿微屈</li><li>收腿并收腹,然后慢慢还原</li><li>3*12(可以先从基本的v字支撑,即不动的版本开始练习)</li></ul><h2 id="西西里卷腹"><a href="#西西里卷腹" class="headerlink" title="西西里卷腹"></a>西西里卷腹</h2><p><img src="../../../../img/fitness/11.jpg" alt="卷腹"><br>要点:</p><ul><li>仰卧在瑜伽垫上,屈膝,手臂向上伸直,双手握紧</li><li>慢慢卷起上半身,卷腹时手臂伸直</li><li>下背部贴紧地面</li><li>3*12</li></ul><h2 id="蹬单车"><a href="#蹬单车" class="headerlink" title="蹬单车"></a>蹬单车</h2><p><img src="../../../../img/fitness/12.jpg" alt="蹬单车"><br>要点:</p><ul><li>仰卧在瑜伽垫上,双臂贴紧地面,双腿与地面30度</li><li>双脚交替屈伸,动作缓慢</li><li>3*30s</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>做这些动作都不可以过快,做到最顶点可以加上停顿,做完之后记得拉伸</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>目前就想这么多啦,考虑到健身房人很多,大部分动作都是给你安排在瑜伽房中的,等以后远远慢慢入门了也可以练习更多动作~<br>既然你每天次都想做跑步或者单车这样的有氧,那么就大概一周三次,连一次臀腿加跑步或单车,上肢加跑步或单车,然后腹部加跑步或单车.当然,也可以根据自己具体想法来調整训练.<br>最后最后,有什么不懂的就来请教元老大吧!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;远远去健身房办卡啦,她有点害羞,不知道做什么好,给远远一份健身计划~&lt;br&gt;
    
    </summary>
    
      <category term="life" scheme="http://yoursite.com/categories/life/"/>
    
    
      <category term="fitness" scheme="http://yoursite.com/tags/fitness/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务管理</title>
    <link href="http://yoursite.com/2018/04/16/Spring-transaction/"/>
    <id>http://yoursite.com/2018/04/16/Spring-transaction/</id>
    <published>2018-04-16T12:42:08.000Z</published>
    <updated>2018-04-16T14:38:26.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库事务基础知识"><a href="#数据库事务基础知识" class="headerlink" title="数据库事务基础知识"></a>数据库事务基础知识</h1><p>一个数据库事务是一个被视为单一的工作单元的操作序列。这些操作应该要么完整地执行，要么完全不执行。数据库事务必须满足下列四个特性ACID（Atomic，Consistency，Isolation，Durabiliy）：</p><ul><li>原子性：组成事务的多个数据库操作是一个不可分的原子单元，只有所有的操作成功执行，事务才会提交。</li><li>一致性：事务操作成功后，数据库所处的状态是和他的业务规则是一致的，即数据不会被破坏。</li><li>隔离性：并发操作数据时，不同的事务拥有各自的空间，他们的操作不会互相干扰。</li><li>持久性：一旦事务提交成功后，事务中所有的数据操作都必须持久化到数据库中。<a id="more"></a><h1 id="ThreadLocal基础知识"><a href="#ThreadLocal基础知识" class="headerlink" title="ThreadLocal基础知识"></a>ThreadLocal基础知识</h1>ThreadLocal是一个保存线程本地化对象的容器。当运行于多线程环境的某个对象使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程分配一个独立的变量副本。每个线程可以独立的改变自己的副本，而不会影响到其他线程所对应的副本。<h2 id="ThreadLocal接口"><a href="#ThreadLocal接口" class="headerlink" title="ThreadLocal接口"></a>ThreadLocal接口</h2>ThreadLocal有4个方法：</li><li>void set(Object value):设置当前线程的局部变量的值。</li><li>public Object get():返回当前线程所对应的线程局部变量。</li><li>public void remove():将当前线程的局部变量的值山粗，目的是为了减少内存占用。</li><li>protected Object initialValue():返回该线程局部变量的初始值。该方法为了让子类覆盖而设计。这是一个延迟调用的方法，直到第一次调用set()或者get()时才执行，并只执行一次。默认返回一个null。</li></ul><p>一个ThreadLocal的简单实现版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.ThreadLocal;</span><br><span class="line"></span><br><span class="line">import org.omg.PortableInterceptor.ObjectReferenceFactory;</span><br><span class="line"></span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class SimpleThreadLocal &#123;</span><br><span class="line">    private Map valueMap= Collections.synchronizedMap(new HashMap());</span><br><span class="line"></span><br><span class="line">    public void set(Object newValue)&#123;</span><br><span class="line">        valueMap.put(Thread.currentThread(),newValue);//键为线程对象，值为线程的变量副本</span><br><span class="line">    &#125;</span><br><span class="line">    public Object get()&#123;</span><br><span class="line">        Thread thread=Thread.currentThread();</span><br><span class="line">        Object o=valueMap.get(thread);//返回本线程对应的变量</span><br><span class="line">        if(o==null &amp;&amp; valueMap.containsKey(thread))&#123;//如果不在map中，保存起来</span><br><span class="line">            o=initialValue();</span><br><span class="line">            valueMap.put(thread,o);</span><br><span class="line">        &#125;</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line">    public void remove()&#123;</span><br><span class="line">        valueMap.remove(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">    public Object initialValue()&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h2><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.ThreadLocal;</span><br><span class="line"></span><br><span class="line">import sun.awt.AWTAccessor;</span><br><span class="line"></span><br><span class="line">public class SequenceNumber &#123;</span><br><span class="line">    private static ThreadLocal&lt;Integer&gt; seqNum=new ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Integer initialValue() &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    /*</span><br><span class="line">    通过匿名内部类覆盖ThreadLocal的initialValue方法，制定初始值</span><br><span class="line">     */</span><br><span class="line">    public int getNextNum()&#123; //获取下一个序列值</span><br><span class="line">        seqNum.set(seqNum.get()+1);</span><br><span class="line">        return seqNum.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        SequenceNumber sequenceNumber=new SequenceNumber();</span><br><span class="line"></span><br><span class="line">        TestClient t1=new TestClient(sequenceNumber);</span><br><span class="line">        TestClient t2=new TestClient(sequenceNumber);</span><br><span class="line">        TestClient t3=new TestClient(sequenceNumber);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class TestClient extends Thread &#123;</span><br><span class="line">        private SequenceNumber sequenceNumber;</span><br><span class="line"></span><br><span class="line">        public TestClient(SequenceNumber sequenceNumber) &#123;</span><br><span class="line">            this.sequenceNumber = sequenceNumber;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for(int i=0;i&lt;3;i++)&#123;//每个线程打印3个值</span><br><span class="line">                System.out.println(&quot;Thread[&quot;+Thread.currentThread().getName()+&quot;] sequenceNumber[&quot;+sequenceNumber.getNextNum()+&quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过内部匿名类类覆盖ThreadLocal中的initialValue（）方法来提供初始值，运行代码得到结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread[Thread-0] sequenceNumber[1]</span><br><span class="line">Thread[Thread-1] sequenceNumber[1]</span><br><span class="line">Thread[Thread-1] sequenceNumber[2]</span><br><span class="line">Thread[Thread-2] sequenceNumber[1]</span><br><span class="line">Thread[Thread-2] sequenceNumber[2]</span><br><span class="line">Thread[Thread-2] sequenceNumber[3]</span><br><span class="line">Thread[Thread-1] sequenceNumber[3]</span><br><span class="line">Thread[Thread-0] sequenceNumber[2]</span><br><span class="line">Thread[Thread-0] sequenceNumber[3]</span><br></pre></td></tr></table></figure></p><p>可以发现虽然三个线程公用一个SequenceNumber实例，但是并没有相互干扰，产生了独立的序列号，因为ThreadLocal为他们提供了单独的副本。</p><h1 id="使用XML配置声明事务"><a href="#使用XML配置声明事务" class="headerlink" title="使用XML配置声明事务"></a>使用XML配置声明事务</h1><p>可以让事务管理的代码完全从业务代码中移除，对代码入侵性最小。</p><p>##　基于aop/tx命名空间的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span><br><span class="line">     http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt;</span><br><span class="line">&lt;!--引入DataSource的配置文件 --&gt;</span><br><span class="line">    &lt;import resource=&quot;classpath:applicationContext-dao.xml&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--事务管理器 --&gt;</span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot;</span><br><span class="line">          class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span><br><span class="line">          p:dataSource-ref=&quot;dataSource&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--使用切点表达式语言定义切点 --&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">&lt;!--定义事务增强切面 --&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;serviceMethod&quot;</span><br><span class="line">                      expression=&quot;execution(* com.smart.service.*Forum.*(..))&quot;/&gt;</span><br><span class="line">&lt;!--引用事务增强 --&gt;</span><br><span class="line">        &lt;aop:advisor pointcut-ref=&quot;serviceMethod&quot;</span><br><span class="line">                     advice-ref=&quot;txAdvice&quot;/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;!--事务增强 --&gt;</span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot;&gt;</span><br><span class="line">&lt;!--事务属性定义 --&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; read-only=&quot;false&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;add*&quot; rollback-for=&quot;PessimisticLockingFailureException&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;update*&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>首先在配置文件中引入tx命名空间，aop命名空间中，通过切点表达式语言，配合<a href="tx:advise" target="_blank" rel="noopener">tx:advise</a>的<a href="aop:advisor" target="_blank" rel="noopener">aop:advisor</a>完成了事务切面的定义。<a href="aop:advisor" target="_blank" rel="noopener">aop:advisor</a>引用的txAdvice增强是在tx空间上定义的。首先，事务增强一定需要一个事务管理器的支持，<a href="tx:advice" target="_blank" rel="noopener">tx:advice</a>通过transaction-manager属性引用了定义为transactionManager的事务管理器。　　<br><a href="tx:method" target="_blank" rel="noopener">tx:method</a>的属性如下：</p><ul><li>name：必要属性，表示与事务相关的方法名。</li><li>pro[agation：事务传播行为，默认ＲＥＱＵＩＲＥＤ</li><li>isolatisosn：事务隔离级别，默认ＤＥＦＡＵＬＴ</li><li>timeout：超时时间，默认系统底层决定</li><li>read-only：是否只读，默认ｆｌａｓｅ</li><li>rollback-for：触发事务回滚的Ｅｘｃｅｐｔｉｏｎ，用于异常名片段匹配。</li></ul><h1 id="使用注解方式声明事务"><a href="#使用注解方式声明事务" class="headerlink" title="使用注解方式声明事务"></a>使用注解方式声明事务</h1><h2 id="使用-Transaction注解"><a href="#使用-Transaction注解" class="headerlink" title="使用@Transaction注解"></a>使用@Transaction注解</h2><p>业务类代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package com.smart.service;</span><br><span class="line"></span><br><span class="line">import com.smart.dao.ForumDao;</span><br><span class="line">import com.smart.dao.PostDao;</span><br><span class="line">import com.smart.dao.TopicDao;</span><br><span class="line">import com.smart.domain.Forum;</span><br><span class="line">import com.smart.domain.Topic;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line">// 对业务类进行事务增强的标注</span><br><span class="line">@Service</span><br><span class="line">@Transactional</span><br><span class="line">public class BbtForum &#123;</span><br><span class="line">    public ForumDao forumDao;</span><br><span class="line"></span><br><span class="line">    public TopicDao topicDao;</span><br><span class="line"></span><br><span class="line">    public PostDao postDao;</span><br><span class="line"></span><br><span class="line">    public void addTopic(Topic topic) throws Exception &#123;</span><br><span class="line">        topicDao.addTopic(topic);</span><br><span class="line">//if(true) throw new PessimisticLockingFailureException(&quot;fail&quot;);</span><br><span class="line">        postDao.addPost(topic.getPost());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Transactional(readOnly = true)</span><br><span class="line">    public Forum getForum(int forumId) &#123;</span><br><span class="line">        return forumDao.getForum(forumId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void updateForum(Forum forum) &#123;</span><br><span class="line">        forumDao.updateForum(forum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getForumNum() &#123;</span><br><span class="line">        return forumDao.getForumNum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setForumDao(ForumDao forumDao) &#123;</span><br><span class="line">        this.forumDao = forumDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setPostDao(PostDao postDao) &#123;</span><br><span class="line">        this.postDao = postDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setTopicDao(TopicDao topicDao) &#123;</span><br><span class="line">        this.topicDao = topicDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注解本身有一组普适性的默认事务属性，可以直接只用注解完成事务配置<br>配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span><br><span class="line">     http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.smart&quot;/&gt;</span><br><span class="line">    &lt;import resource=&quot;classpath:applicationContext-dao.xml&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bbtForum&quot;</span><br><span class="line">          class=&quot;com.smart.service.BbtForum&quot;</span><br><span class="line">          p:forumDao-ref=&quot;forumDao&quot;</span><br><span class="line">          p:topicDao-ref=&quot;topicDao&quot;</span><br><span class="line">          p:postDao-ref=&quot;postDao&quot;/&gt;</span><br><span class="line">&lt;!--配置事务管理器--&gt;</span><br><span class="line">    &lt;bean id=&quot;txManager&quot;</span><br><span class="line">          class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span><br><span class="line">          p:dataSource-ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">&lt;!-- 对标志注解@Transaction的bean加工处理，以织入事务管理切面--&gt;</span><br><span class="line">    &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; proxy-target-class=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p><a href="tx:annotation-driven" target="_blank" rel="noopener">tx:annotation-driven</a>有三个属性：</p><ul><li>transaction-manager：指定事务管理器</li><li>proxy-target-class：如果位true，Spring将通过创建子类来代理业，否则基于接口代理</li><li>order：控制事务切面在目标连接点的织入顺序</li></ul><p>@Transaction注解属性：</p><ul><li>value     String     可选的限定描述符，指定使用的事务管理器</li><li>propagation     enum: Propagation     可选的事务传播行为设置</li><li>isolation     enum: Isolation     可选的事务隔离级别设置</li><li>readOnly     boolean     读写或只读事务，默认读写</li><li>timeout     int (in seconds granularity)     事务超时时间设置</li><li>rollbackFor     Class对象数组，必须继承自Throwable     导致事务回滚的异常类数组</li><li>rollbackForClassName     类名数组，必须继承自Throwable     导致事务回滚的异常类名字数组</li><li>noRollbackFor     Class对象数组，必须继承自Throwable     不会导致事务回滚的异常类数组</li><li><p>noRollbackForClassName     类名数组，必须继承自Throwable     不会导致事务回滚的异常类名字数组</p><p>@Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。<br>虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。<em>建议在业务实现类上使用该注解。</em>另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。<br>在方法上使用@Transaction注解会覆盖类上的注解的属性。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Spring事务配置主要提供两方面信息：1.切点信息，用于定位实施事务切面的业务类方法。2.控制事务行为的事务属性，如事务隔离级别，传播行为等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据库事务基础知识&quot;&gt;&lt;a href=&quot;#数据库事务基础知识&quot; class=&quot;headerlink&quot; title=&quot;数据库事务基础知识&quot;&gt;&lt;/a&gt;数据库事务基础知识&lt;/h1&gt;&lt;p&gt;一个数据库事务是一个被视为单一的工作单元的操作序列。这些操作应该要么完整地执行，要么完全不执行。数据库事务必须满足下列四个特性ACID（Atomic，Consistency，Isolation，Durabiliy）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性：组成事务的多个数据库操作是一个不可分的原子单元，只有所有的操作成功执行，事务才会提交。&lt;/li&gt;
&lt;li&gt;一致性：事务操作成功后，数据库所处的状态是和他的业务规则是一致的，即数据不会被破坏。&lt;/li&gt;
&lt;li&gt;隔离性：并发操作数据时，不同的事务拥有各自的空间，他们的操作不会互相干扰。&lt;/li&gt;
&lt;li&gt;持久性：一旦事务提交成功后，事务中所有的数据操作都必须持久化到数据库中。
    
    </summary>
    
      <category term="study" scheme="http://yoursite.com/categories/study/"/>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-AspectJ</title>
    <link href="http://yoursite.com/2018/04/13/Spring-AspectJ/"/>
    <id>http://yoursite.com/2018/04/13/Spring-AspectJ/</id>
    <published>2018-04-13T06:33:17.000Z</published>
    <updated>2018-04-15T11:53:04.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AspectJ"><a href="#AspectJ" class="headerlink" title="@AspectJ"></a>@AspectJ</h1><p>前面Spring AOP的配置十分复杂，需要在XML文件中包含许多代码，但使用@AspectJ后，可以非常容易的定义一个切面。<br><a id="more"></a></p><h2 id="AspectJ语法"><a href="#AspectJ语法" class="headerlink" title="@AspectJ语法"></a>@AspectJ语法</h2><h3 id="切点函数"><a href="#切点函数" class="headerlink" title="切点函数"></a>切点函数</h3><p>Spring支持9个切点表达式函数，分为以下4类：</p><ul><li>方法切入点函数：可以通过描述目标类方法的信息定义连接点。</li><li>方法入参切点函数：通过描述目标类方法的入参的信息定义连接点。</li><li>目标类切点函数：通过描述目标类类型的信息定义连接点。</li><li>代理类切点函数：通过描述目标类的代理类的信息来定义连接点。</li></ul><p>如下表：</p><table><br>  <tr><br>    <th width="10%," bgcolor="yellow">类别</th><br>    <th width="10%," bgcolor="yellow">函数</th><br>    <th width="10%," bgcolor="yellow">入参</th><br>    <th width="70%," bgcolor="yellow">说明</th><br>  </tr><br>  <tr><br>    <td bgcolor="red">方法切点函数 </td><br>    <td> execution  </td><br>    <td> 方法匹配模式串 </td><br>    <td>表示满足某一匹配模式的所有目标类方法连接点。如execution(<em> greetTo(..))表示所有目标类中的greetTo()方法。 </em></td><br>  </tr><br>  <tr><br>    <td bgcolor="red">方法切点函数 </td><br>    <td> @annotation()</td><br>    <td> 方法注解类名</td><br>    <td>表示标注了特定注解的目标方法连接点。如@annotation(com.baobaotao.anno.NeedTest)表示任何标注了@NeedTest注解的目标类方法.</td><br>  </tr><br>  <tr><br>    <td bgcolor="blue">方法入参切点函数</td><br>    <td>args()</td><br>    <td>类名</td><br>    <td>通过判别目标类方法运行时入参对象的类型定义指定连接点。如args(com.baobaotao.Waiter)表示所有有且仅有一个按类型匹配于Waiter的入参的方法。</td><br>  </tr><br>  <tr><br>    <td bgcolor="blue">方法入参切点函数</td><br>    <td>@args()</td><br>    <td>类型注解名</td><br>    <td>通过判别目标方法的运行时入参对象的类是否标注特定注解来指定连接点。如@args(com.baobaotao.Monitorable)表示任何这样的一个目标方法：它有一个入参且入参对象的类标注@Monitorable注解。</td><br>  </tr><br>  <tr><br>    <td bgcolor="grey">目标类切点函数 </td><br>    <td>within()</td><br>    <td>类名匹配串</td><br>    <td>表示特定域下的所有连接点。如within(com.baobaotao.service.)表示com.baobaotao.service包中的所有连接点，也即包中所有类的所有方法，而within(com.baobaotao.service.*Service)表示在com.baobaotao.service包中，所有以Service结尾的类的所有连接点。</td><br>  </tr><br>  <tr><br>    <td bgcolor="grey">目标类切点函数  </td><br>    <td>target()</td><br>    <td>类名</td><br>    <td> 假如目标类按类型匹配于指定类，则目标类的所有连接点匹配这个切点。如通过target(com.baobaotao.Waiter)定义的切点，Waiter、以及Waiter实现类NaiveWaiter中所有连接点都匹配该切点。</td><br>  </tr><br>  <tr><br>    <td bgcolor="grey">目标类切点函数 </td><br>    <td>@within()</td><br>    <td>类型注解类名</td><br>    <td> 假如目标类按类型匹配于某个类A，且类A标注了特定注解，则目标类的所有连接点匹配这个切点 如@within(com.baobaotao.Monitorable)定义的切点，假如Waiter类标注了@Monitorable注解，则Waiter以及Waiter实现类NaiveWaiter类的所有连接点都匹配。 </td><br>  </tr><br>  <tr><br>    <td bgcolor="grey">目标类切点函数  </td><br>    <td>@target()</td><br>    <td>类型注解类名</td><br>    <td>目标类标注了特定注解，则目标类所有连接点匹配该切点。如@target(com.baobaotao.Monitorable)，假如NaiveWaiter标注了@Monitorable，则NaiveWaiter所有连接点匹配切点。</td><br>  </tr><br>  <tr><br>    <td bgcolor="green">代理类切点函数  </td><br>    <td>this() </td><br>    <td>类名 </td><br>    <td>主要为this()，大多数情况使用方法与target()相同，区别在通过引介增强引入新接口方法时，新的接口方法同样会被this()定位，但target()则不会。</td><br>  </tr><br></table><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>我们来了解下AspectJ类型匹配的通配符：</p><ul><li>*：匹配任何数量字符</li><li>..：匹配任何数量字符的重复，如在类型模式中匹配任何数量子包；而在方法参数模式中匹配任何数量参数</li><li>+：匹配指定类型的子类型；仅能作为后缀放在类型模式后边</li></ul><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.String    匹配String类型；  </span><br><span class="line">java.*.String       匹配java包下的任何“一级子包”下的String类型；  </span><br><span class="line">如匹配java.lang.String，但不匹配java.lang.ss.String  </span><br><span class="line">java..*            匹配java包及任何子包下的任何类型;  </span><br><span class="line">                  如匹配java.lang.String、java.lang.annotation.Annotation  </span><br><span class="line">java.lang.*ing      匹配任何java.lang包下的以ing结尾的类型；  </span><br><span class="line">java.lang.Number+  匹配java.lang包下的任何Number的自类型；  </span><br><span class="line">                   如匹配java.lang.Integer，也匹配java.math.BigInteger</span><br></pre></td></tr></table></figure></p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ul><li>&amp;&amp;: 与操作符，等效and</li><li>||：或操作符，等效or</li><li>！：非操作符，等效not</li></ul><p>如：！winth(com.demo1.<em>)表示所有不在com.demo3包中的方法<br>   winth（com.demo1.</em>)&amp;&amp;args(String)表示在com.demo1包下所有类拥有一个String参数的方法<br>   winth(com.demo1.*)||args(String)表示在com.demo1包下或者拥有一个参数为String的所有方法</p><h2 id="不同增强类型"><a href="#不同增强类型" class="headerlink" title="不同增强类型"></a>不同增强类型</h2><ul><li>@Before：前置增强，相当于BeforeAdvice。Before注解有两个类成员。<ul><li>value：该成员用于定义切点</li><li>argNames：由于无法通过Java反射机制获取方法入参名，如果在Java编译时未启动调用信息，或者需要在运行期间解析切点，就必须通过这个成员指定注解所标注增强的方法参数名（两者名字必须相同），多个参数用逗号分离</li></ul></li><li>AfterReturning：后置增强，相当于AfterReturningAdvice。AfterReturning有四个类成员<ul><li>value：定义切点</li><li>pointcut：表示切点的信息。如果显式指定pointcut的值，将覆盖value的值，可以将pointcut看做value的近义词</li><li>returning：将目标对象方法的返回值绑定给增强的方法。<br>+argNames：同前面</li></ul></li><li>Around：环绕增强，相当于MethodInterceptor。两个类成员<ul><li>value</li><li>argNames</li></ul></li><li>AfterThrowing：抛出增强，相当于ThrowAdvice。四个类成员<ul><li>value</li><li>pointcut</li><li>throwing：将抛出的异常保绑定在增强方法中</li><li>argNames</li></ul></li><li>@After：final增强，不管是抛出异常还是正常退出，该增强都会得到执行。两个类成员。<ul><li>value</li><li>argNames</li></ul></li><li>DeclareParents：引介增强，相当于IntroductionInterceptor。两个类成员。<ul><li>value</li><li>defaultImpl：默认接口实现类</li></ul></li></ul><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>NaiveWaiter代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com;</span><br><span class="line"></span><br><span class="line">public class NaiveWaiter implements Waiter &#123;</span><br><span class="line">    public void greetTo(String name) &#123;</span><br><span class="line">        System.out.println(&quot;greet to &quot;+name+&quot;!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void serverTo(String name) &#123;</span><br><span class="line">        System.out.println(&quot;server to &quot;+name+&quot;!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用@AspectJ定义一个切面PreGreetingAspect：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.AspectJ;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Before;</span><br><span class="line">@Aspect </span><br><span class="line">public class PreGreetingAspect &#123;</span><br><span class="line">    @Before(&quot;execution(* greetTo(..))&quot;)</span><br><span class="line">    public  void beforeGreeting()&#123;</span><br><span class="line">        System.out.println(&quot;how are you~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@AspectJ注解表示该类是一个切面。Before注解表示该增强是前置增强,成员值表示在目标类的greetTo方法上添加增强，greetTo（）方法可以带任意的参数和返回值。PreGreetingAspect类相当于BeforeAdvice，NameMatchMethodPointcut，DefaultPointcutAdvisor三者联合表达的信息。<br>配置@Aspect切面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--给予@AspectJ切面的驱动器--&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy/&gt;</span><br><span class="line">    &lt;!--目标bean--&gt;</span><br><span class="line">    &lt;bean id=&quot;waiter&quot; class=&quot;com.NaiveWaiter&quot;/&gt;</span><br><span class="line">    &lt;!-- 使用AspectJ注解的切面类--&gt;</span><br><span class="line">    &lt;bean class=&quot;com.AspectJ.PreGreetingAspect&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p><code>&lt;aop:aspectj-autoproxy/&gt;</code>自动为Spring容器中那些匹配@AspectJ切面的Bean创建代理，完成切面织入。  </p><h2 id="命名切点"><a href="#命名切点" class="headerlink" title="命名切点"></a>命名切点</h2><p>上一个例子，切点直接在增强方法处声明，这种方式称为匿名切点，匿名切点只能在声明处使用。如果需要在其他地方重用一个切点，可以通过@Pointcut注解以及切面类的方法来命名切点。<br>一个切入点有助于确定使用不同建议执行的感兴趣的连接点（即方法）。在处理基于配置的 XML 架构时，切入点的声明有两个部分：</p><ul><li>一个切入点表达式决定了我们感兴趣的哪个方法会真正被执行</li><li>一个切入点标签包含一个名称和任意数量的参数。方法的真正内容是不相干的，并且实际上它应该是空的</li></ul><p>###例子<br>一个目标POJO类Student：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.PointCut;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        System.out.println(&quot;Name:&quot;+name);</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        System.out.println(&quot;Age:&quot;+age);</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printThrowException()throws Exception&#123;</span><br><span class="line">        System.out.println(&quot;Exception raised&quot;);</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义了切点的切面Logging：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.PointCut;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">public class Logging &#123;</span><br><span class="line">    @Pointcut(&quot;execution(* com.PointCut.*.*(..))&quot;)</span><br><span class="line">    private void selectAll()&#123;&#125;//定义一个切点，定位在com.PointCut中所有类，所有方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Before(&quot;selectAll()&quot;)</span><br><span class="line">    public void beforeAdvice()&#123;</span><br><span class="line">        System.out.println(&quot;Going to setup Student profile&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(&quot;selectAll()&quot;)</span><br><span class="line">    public void afterAdvice()&#123;</span><br><span class="line">        System.out.println(&quot;Student profile has been setup&quot;);</span><br><span class="line">    &#125;//final增强，无论何时都会执行</span><br><span class="line"></span><br><span class="line">    @AfterReturning(pointcut = &quot;selectAll()&quot;,returning = &quot;returnVal&quot;)</span><br><span class="line">    public void afterReturning(Object returnVal)&#123;</span><br><span class="line">        System.out.println(&quot;Returning&quot;+returnVal.toString());</span><br><span class="line">    &#125;// 在selectAll切点定位的连接点织入后置增强，无论返回任何方式的返回值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @AfterThrowing(pointcut = &quot;selectAll()&quot;, throwing = &quot;ex&quot;)</span><br><span class="line">    public void AfterThrowingAdvice(IllegalArgumentException ex)&#123;</span><br><span class="line">        System.out.println(&quot;There has been an exception: &quot; + ex.toString());</span><br><span class="line">    &#125;//当遇到异常抛出时，该增强被执行。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>XML配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--基于@AspectJ切面的驱动器--&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--目标bean--&gt;</span><br><span class="line">    &lt;bean id=&quot;student&quot; class=&quot;com.PointCut.Student&quot;</span><br><span class="line">          p:name=&quot;wade&quot;</span><br><span class="line">          p:age=&quot;21&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--使用了AspectJ的切面类 --&gt;</span><br><span class="line">    &lt;bean id=&quot;logging&quot; class=&quot;com.PointCut.Logging&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com;</span><br><span class="line"></span><br><span class="line">import com.PointCut.Student;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">import org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line">public class TestPointcut &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test()throws Exception&#123;</span><br><span class="line">        ApplicationContext context=new ClassPathXmlApplicationContext(&quot;com/PointCut/PointCut.xml&quot;);</span><br><span class="line">        Student student=(Student)context.getBean(&quot;student&quot;);</span><br><span class="line">        student.getAge();</span><br><span class="line">        student.getName();</span><br><span class="line">        student.printThrowException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Going to setup Student profile</span><br><span class="line">Age:21</span><br><span class="line">Student profile has been setup</span><br><span class="line">Returning21</span><br><span class="line">Going to setup Student profile</span><br><span class="line">Name:wade</span><br><span class="line">Student profile has been setup</span><br><span class="line">Returningwade</span><br><span class="line">Going to setup Student profile</span><br><span class="line">Exception raised</span><br><span class="line">Student profile has been setup</span><br><span class="line">There has been an exception: java.lang.IllegalArgumentException</span><br><span class="line">..............</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用@AspectJ注解可以简化Spring AOP，需要自己记住那些复杂的切点函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AspectJ&quot;&gt;&lt;a href=&quot;#AspectJ&quot; class=&quot;headerlink&quot; title=&quot;@AspectJ&quot;&gt;&lt;/a&gt;@AspectJ&lt;/h1&gt;&lt;p&gt;前面Spring AOP的配置十分复杂，需要在XML文件中包含许多代码，但使用@AspectJ后，可以非常容易的定义一个切面。&lt;br&gt;
    
    </summary>
    
      <category term="study" scheme="http://yoursite.com/categories/study/"/>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>bike</title>
    <link href="http://yoursite.com/2018/04/11/bike/"/>
    <id>http://yoursite.com/2018/04/11/bike/</id>
    <published>2018-04-11T15:06:05.000Z</published>
    <updated>2018-04-11T15:23:33.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NEW-CAR-—-小圆子"><a href="#NEW-CAR-—-小圆子" class="headerlink" title="NEW CAR!!—-小圆子"></a>NEW CAR!!—-小圆子</h1><p>4.9小窝中又加了新的成员啦=!=<br>他叫小圆子，我们的新车，和远远一起拐到我们家啦，也算是完成了上学期的小目标  </p><h2 id="DIY-Time"><a href="#DIY-Time" class="headerlink" title="DIY Time"></a>DIY Time</h2><p>刚收到小圆子的话他被装在一个大大的长方形盒子，安静的躺好了。然后两个人一起装了大概两节课吧，第一次体验组装单车，还好远远心灵手巧～<br><img src="../../../../img/bike/bike3.jpg" alt="bike3"><br><a id="more"></a><br><img src="../../../../img/bike/bike1.jpg" alt="bike1"><br><img src="../../../../img/bike/bike4.jpg" alt="bike4"><br><img src="../../../../img/bike/bike2.jpg" alt="bike2"></p><h2 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h2><p>谈一下小圆子这几天的表现吧。任劳任怨，每天一大早就背着我们吃饭上课去图书馆，晚上还得送我们回家。虽然他一开始一直拉肚子，不过在换了一个胎盖之后就好啦。不过可能是对于我们一天到晚一直骑着它有些生气，骑着的时候有时候会哼哼的叫&gt;!&lt;<br>当然，小圆子还是很不错的，很喜欢。以后好好表现咯～</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;NEW-CAR-—-小圆子&quot;&gt;&lt;a href=&quot;#NEW-CAR-—-小圆子&quot; class=&quot;headerlink&quot; title=&quot;NEW CAR!!—-小圆子&quot;&gt;&lt;/a&gt;NEW CAR!!—-小圆子&lt;/h1&gt;&lt;p&gt;4.9小窝中又加了新的成员啦=!=&lt;br&gt;他叫小圆子，我们的新车，和远远一起拐到我们家啦，也算是完成了上学期的小目标  &lt;/p&gt;
&lt;h2 id=&quot;DIY-Time&quot;&gt;&lt;a href=&quot;#DIY-Time&quot; class=&quot;headerlink&quot; title=&quot;DIY Time&quot;&gt;&lt;/a&gt;DIY Time&lt;/h2&gt;&lt;p&gt;刚收到小圆子的话他被装在一个大大的长方形盒子，安静的躺好了。然后两个人一起装了大概两节课吧，第一次体验组装单车，还好远远心灵手巧～&lt;br&gt;&lt;img src=&quot;../../../../img/bike/bike3.jpg&quot; alt=&quot;bike3&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="home" scheme="http://yoursite.com/categories/home/"/>
    
    
      <category term="car" scheme="http://yoursite.com/tags/car/"/>
    
  </entry>
  
  <entry>
    <title>Spring-AOP基础</title>
    <link href="http://yoursite.com/2018/04/11/Spring-AOP/"/>
    <id>http://yoursite.com/2018/04/11/Spring-AOP/</id>
    <published>2018-04-11T03:00:41.000Z</published>
    <updated>2018-04-12T13:36:23.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP是aspect oriented programing的简称，意为面向切面编程。有时候我们无法通过抽象父类消除重复性的横切代码，因为这些横切逻辑依赖在业务流程中，无法转移到另外的地方。AOP希望将这些分散在各个业务逻辑中的相同代码通过横向切割的方式抽取到独立的模块中，还业务逻辑类一个清新的世界。</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>连接点（Joinpoint）：特定点是程序执行的某个位置，如类的开始初始化前，初始化后，类的某个方法调用前后，方法抛出异常后。一个类或者一段程序代码拥有的一些具有边界性质的特定点被成为连接点。Spring仅支持方法的连接点。使用切点对执行点定义，而方位则在增强类中定义。</li><li>切点（Pointcut）：每个程序都有众多的连接点，连接点是客观存在的事务。在众多连接点中定位到我们需要的连接点就是切点。连接点相当于数据库中的记录，切点就是相当于条件查询。切点用过org.springframework.aop.Pointcut接口进行描述，使用类和方法进行作为连接点的查询条件，切点只定位到某方法上，如果需要确定到某连接点，还需要提供方位信息。</li><li>增强（Advice）：增强是织入目标类连接点上的一段程序代码。增强除了用于描述一段代码外，还拥有一个和连接点相关的信息，这便是执行点的方位。所以增强接口都是带方位名的，如：BeforeAdvice，AfterReturningAdvice，ThThrowsAdvice等。只有结合切点增强，才能确定特定连接点的位置，并实施增强逻辑。</li><li>目标对象（Target）：增强织入的目标类。</li><li>引介（Introduction）：引介是一种特殊的增强，它可以为类添加属性和方法。</li><li>织入（Weaving）:织入是将增强添加到目标类的具体连接点上。</li><li>代理（Proxy）：一个类被AOP织入增强后，就产生了一个结果类，他是融合了原类和增强逻辑的代理类。</li></ul><a id="more"></a><h2 id="底层工作机理"><a href="#底层工作机理" class="headerlink" title="底层工作机理"></a>底层工作机理</h2><p>Spring AOP使用了两种代理机制：一种是基于JDK的动态代理；另一种是基于GGLib的动态代理。</p><h3 id="带有横切逻辑的实例"><a href="#带有横切逻辑的实例" class="headerlink" title="带有横切逻辑的实例"></a>带有横切逻辑的实例</h3><p>forumService接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.JDK_Proxy;</span><br><span class="line"></span><br><span class="line">public interface ForumService &#123;</span><br><span class="line">void removeTopic(int topicId);</span><br><span class="line">void removeForum(int forumId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现forumService的类，其中包含了性能监视的横切逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.JDK_Proxy;</span><br><span class="line"></span><br><span class="line">public class ForumServiceImpl implements ForumService &#123;</span><br><span class="line"></span><br><span class="line">public void removeTopic(int topicId) &#123;</span><br><span class="line">PerformanceMonitor.begin(&quot;com.smart.proxy.ForumServiceImpl.removeTopic&quot;);//开始对方法进行性能监视</span><br><span class="line">System.out.println(&quot;模拟删除Topic记录:&quot;+topicId);</span><br><span class="line">try &#123;</span><br><span class="line">Thread.currentThread().sleep(20);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">PerformanceMonitor.end();//结束监视</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void removeForum(int forumId) &#123;</span><br><span class="line">PerformanceMonitor.begin(&quot;com.smart.proxy.ForumServiceImpl.removeForum&quot;);//开始监视</span><br><span class="line">System.out.println(&quot;模拟删除Forum记录:&quot;+forumId);</span><br><span class="line">try &#123;</span><br><span class="line">Thread.currentThread().sleep(40);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">PerformanceMonitor.end();//结束监视</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在该类中，每个业务方法都有执行相同的逻辑代码，启动与结束监视。  </p><p>PerformanceMonitor：性能监视类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.JDK_Proxy;</span><br><span class="line"></span><br><span class="line">public class PerformanceMonitor &#123;</span><br><span class="line">private static ThreadLocal&lt;MethodPerformace&gt; performaceRecord = new ThreadLocal&lt;MethodPerformace&gt;();</span><br><span class="line"></span><br><span class="line">public static void begin(String method) &#123;</span><br><span class="line">System.out.println(&quot;begin monitor...&quot;);</span><br><span class="line">MethodPerformace mp = performaceRecord.get();</span><br><span class="line">if(mp == null)&#123;</span><br><span class="line">mp = new MethodPerformace(method);</span><br><span class="line">performaceRecord.set(mp);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    mp.reset(method);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void end() &#123;</span><br><span class="line">System.out.println(&quot;end monitor...&quot;);</span><br><span class="line">MethodPerformace mp = performaceRecord.get();</span><br><span class="line">mp.printPerformace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MethodPerformance：记录性能监视的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.JDK_Proxy;</span><br><span class="line"></span><br><span class="line">public class MethodPerformace &#123;</span><br><span class="line">private long begin;</span><br><span class="line">private long end;</span><br><span class="line">private String serviceMethod;</span><br><span class="line">    public MethodPerformace(String serviceMethod)&#123;</span><br><span class="line">    reset(serviceMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    public void printPerformace()&#123;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        long elapse = end - begin;</span><br><span class="line">        System.out.println(serviceMethod+&quot;花费&quot;+elapse+&quot;毫秒。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void reset(String serviceMethod)&#123;</span><br><span class="line">    this.serviceMethod = serviceMethod;</span><br><span class="line">    this.begin = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.JDK_Proxy;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ForumService forumService=new ForumServiceImpl();</span><br><span class="line">        forumService.removeTopic(12);</span><br><span class="line">        forumService.removeForum(21);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin monitor...</span><br><span class="line">模拟删除Topic记录:12</span><br><span class="line">end monitor...</span><br><span class="line">com.smart.proxy.ForumServiceImpl.removeTopic花费20毫秒。</span><br><span class="line">begin monitor...</span><br><span class="line">模拟删除Forum记录:21</span><br><span class="line">end monitor...</span><br><span class="line">com.smart.proxy.ForumServiceImpl.removeForum花费43毫秒。</span><br></pre></td></tr></table></figure></p><p>在以上例子中，在forumServiceImpl业务逻辑代码中都加入了开启，关闭性能监视的代码，破坏了编程的纯粹性。通过代理的方式可以将业务类方法中开启和结束性能监视的横切代码抽象出来，通过JDK动态代理的方式将横切代码动态的织入目标方法的相应位置。</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理主要涉及java.lang.reflect包中的两类：Proxy和InvocationHandler。其中InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态的将横切逻辑与业务编制到一起。</p><p>首先从forumServiceImpl中移除性能监视的代码，使其只负责具体的业务逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.JDK_Proxy;</span><br><span class="line"></span><br><span class="line">public class ForumServiceImpl implements ForumService &#123;</span><br><span class="line"></span><br><span class="line">public void removeTopic(int topicId) &#123;</span><br><span class="line">//PerformanceMonitor.begin(&quot;com.smart.proxy.ForumServiceImpl.removeTopic&quot;);</span><br><span class="line">System.out.println(&quot;模拟删除Topic记录:&quot;+topicId);</span><br><span class="line">try &#123;</span><br><span class="line">Thread.currentThread().sleep(20);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">//PerformanceMonitor.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void removeForum(int forumId) &#123;</span><br><span class="line">//PerformanceMonitor.begin(&quot;com.smart.proxy.ForumServiceImpl.removeForum&quot;);</span><br><span class="line">System.out.println(&quot;模拟删除Forum记录:&quot;+forumId);</span><br><span class="line">try &#123;</span><br><span class="line">Thread.currentThread().sleep(40);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">//PerformanceMonitor.end();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在业务类中移除了性能监视的代码后，InvocationHandler是其安身的好地方，可将性能监视的代码放在实现了InvocationHandler的PerformanceHandler中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.JDK_Proxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class PerformanceHandler implements InvocationHandler &#123;//实现InvocationHandler类</span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public PerformanceHandler(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;//target为业务目标</span><br><span class="line"></span><br><span class="line">    public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123;//o是最终生产的代理类，method是被代理的目标实例的某个方法，通过它可以发起目标实例方法的反射调用。objects是被代理实例某个方法的入参，在方法反射调用时使用。</span><br><span class="line">        PerformanceMonitor.begin(target.getClass().getName()+&quot;.&quot;+method.getName());</span><br><span class="line">        Object o1=method.invoke(target,objects);//通过反射方法调用业务类的目标方法</span><br><span class="line">        PerformanceMonitor.end();</span><br><span class="line">        return o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过Proxy结合PerformanceHandler创建ForumService接口代理实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.JDK_Proxy;</span><br><span class="line">        import org.testng.annotations.Test;</span><br><span class="line">        import java.lang.reflect.Proxy;</span><br><span class="line">public class ForumServiceTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void proxy()&#123;</span><br><span class="line">        ForumService target=new ForumServiceImpl();</span><br><span class="line">        PerformanceHandler handler=new PerformanceHandler(target);</span><br><span class="line">        ForumService proxy=(ForumService) Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),handler);</span><br><span class="line">        proxy.removeForum(10);</span><br><span class="line">        proxy.removeTopic(11);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用代理实例，得到结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin monitor...</span><br><span class="line">模拟删除Forum记录:10</span><br><span class="line">end monitor...</span><br><span class="line">com.JDK_Proxy.ForumServiceImpl.removeForum花费40毫秒。</span><br><span class="line">begin monitor...</span><br><span class="line">模拟删除Topic记录:11</span><br><span class="line">end monitor...</span><br><span class="line">com.JDK_Proxy.ForumServiceImpl.removeTopic花费20毫秒。</span><br></pre></td></tr></table></figure></p><p>时序图中的整体逻辑：<br><img src="../../../../img/Spring/ForumService.jpg" alt="ForumService"></p><h2 id="创建增强类"><a href="#创建增强类" class="headerlink" title="创建增强类"></a>创建增强类</h2><p>Spring增强总共分为5种：</p><ul><li>前置增强（BeforeAdvice）</li><li>后置增强（AfterReturningAdvice）</li><li>环绕增强（MethodInterceptor）</li><li>异常抛出增强（ThrowAdvice）</li><li>引介增强（IntroductionInterceptor)</li></ul><h3 id="前置增强与后置增强"><a href="#前置增强与后置增强" class="headerlink" title="前置增强与后置增强"></a>前置增强与后置增强</h3><p>一个服务生应当对客户进行招呼和服务，Waiter接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.Advice;</span><br><span class="line"></span><br><span class="line">public interface Waiter &#123;</span><br><span class="line">    void greetTo(String name);</span><br><span class="line">    void serverTo(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个训练不足的服务生在招呼客户时不使用礼貌用语，在服务后不使用礼貌用语，NaiveWaiter类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.Advice;</span><br><span class="line"></span><br><span class="line">public class NaiveWaiter implements Waiter &#123;</span><br><span class="line">    public void greetTo(String name) &#123;</span><br><span class="line">        System.out.println(&quot;greet to &quot;+name+&quot;!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void serverTo(String name) &#123;</span><br><span class="line">        System.out.println(&quot;server to &quot;+name+&quot;!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>让服务生在打招呼前使用的服务用语，GreetingBeforeAdvice类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.Advice;</span><br><span class="line"></span><br><span class="line">import org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class GreetingBeforeAdvice implements MethodBeforeAdvice &#123;</span><br><span class="line">    public void before(Method method, Object[] objects, Object o) throws Throwable &#123; //method为目标类方法,objects为目标方法的入参  o为目标类实例</span><br><span class="line">        String name=(String)objects[0];</span><br><span class="line">        System.out.println(&quot;How are you! Mr&quot;+name+&quot;!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>让服务生在服务后使用的礼貌用语，GreetingAfterAdvice类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.Advice;</span><br><span class="line"></span><br><span class="line">import org.springframework.aop.AfterReturningAdvice;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class GreetingAfterAdvice implements AfterReturningAdvice &#123;</span><br><span class="line">    public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable &#123;</span><br><span class="line">        String name=(String)objects[0];</span><br><span class="line">        System.out.println(&quot;Please enjoy!&quot;+name+&quot;~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在XML中使用Spring的ProxyFactory来配置代理，将增强织入到目标类中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;greetingBeforeAdvice&quot; class=&quot;com.Advice.GreetingBeforeAdvice&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;greatingAfterAdvice&quot; class=&quot;com.Advice.GreetingAfterAdvice&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;target&quot; class=&quot;com.Advice.NaiveWaiter&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;waiter&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span><br><span class="line">          p:proxyInterfaces=&quot;com.Advice.Waiter&quot;</span><br><span class="line">          p:interceptorNames=&quot;greetingBeforeAdvice,greatingAfterAdvice&quot;</span><br><span class="line">          p:target-ref=&quot;target&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>ProxyFactoryBean是FactoryBean接口的实现类,负责为其他Bean创建代理实例,在内部使用ProxyFactory来实现<br>        ProxyFactoryBean属性:<br>            target:代理的目标对象<br>            proxyInterfaces:代理所需要实现的接口,可以是多个接口<br>            interceptorNames:需要织入的目标对象<br>            singleton:返回的代理是否为单实例,默认是<br>            optimize:当设置为True时,使用GGlib动态代理,对于singleton的代理,推荐使用.其他作用域的代理使用JDK动态代理<br>            proxyTargetClass:是否对类进行代理,而不是对接口代理.设置为True时,使用GGLib代理  </p><h3 id="环绕增强"><a href="#环绕增强" class="headerlink" title="环绕增强"></a>环绕增强</h3><p>环绕增强可在目标类方法调用前后织入横切逻辑，使用环绕增强实现前后礼貌用语，GreetingInterceptor类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.Advice;</span><br><span class="line"></span><br><span class="line">import org.aopalliance.intercept.MethodInterceptor;</span><br><span class="line">import org.aopalliance.intercept.MethodInvocation;</span><br><span class="line"></span><br><span class="line">public class GreetingInterceptor implements MethodInterceptor &#123;</span><br><span class="line">    public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123;</span><br><span class="line">        Object[] objects=methodInvocation.getArguments();//获得目标方法的参数</span><br><span class="line">        String name=(String)objects[0];</span><br><span class="line">        System.out.println(&quot;How are you,Mr.&quot;+name+&quot;!&quot;);//在执行目标方法前调用</span><br><span class="line">        Object obj=methodInvocation.proceed();//通过通过反射机制调用目标方法</span><br><span class="line">        System.out.println(&quot;please enjoy&quot;);//在目标方法执行后调用</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Spring直接使用MethodInterceptor作为环绕增强的接口,该接口有唯一的方法：<br>public Object invoke(MethodInvocation methodInvocation) throws Throwable。MethodInvocation不但封装了目标方法及其参数组,还封装了目标方法所在的实力对象,通过MethodInterceptor的getArguments()方法可以获取目标方法的参数组,通过proceed()方法反射调用目标实例相应方法。  </p><p>XML配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;greetingInterceptor&quot; class=&quot;com.Advice.GreetingInterceptor&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;target&quot; class=&quot;com.Advice.NaiveWaiter&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;waiter&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span><br><span class="line">          p:target-ref=&quot;target&quot;</span><br><span class="line">          p:interceptorNames=&quot;greetingInterceptor&quot;</span><br><span class="line">          p:proxyInterfaces=&quot;com.Advice.Waiter&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><h2 id="创建切面"><a href="#创建切面" class="headerlink" title="创建切面"></a>创建切面</h2><p>增强提供了连接点方位，如织入到方法前后，而切点进一步描述了织入哪些类的哪些方法上。<br>PointcutAdvisor包含Advice和Pointcut两类，这样就可以通过上面两类定位到类，方法，方法方位，提供合适的切面。<br>PointcutAdvisor主要有一下几个实现类：</p><ul><li>DefaultPointcutAdvisor：最常用的切面类型，通过任意的Pointcut和Advice定义一个切面，仅不支持引介切面。</li><li>NameMatchMethodPointAdvisor：通过该类可以定义按方法名定义切点的切面。</li><li>StaticMethodMatcherPointcutAdvisor：静态方法匹配切点定义的切面，默认情况下匹配所有目标类。</li></ul><h3 id="静态普通方法名匹配"><a href="#静态普通方法名匹配" class="headerlink" title="静态普通方法名匹配"></a>静态普通方法名匹配</h3><p>StaticMethodMatcherPointcutAdvisor代表一个静态方法匹配切面，通过StaticMethodMatcherPointcut来定义切点，通过类过滤和方法名匹配来定义切点。<br>代码Waiter：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.Advisor;</span><br><span class="line"></span><br><span class="line">public class Waiter &#123;</span><br><span class="line">           public void greetTo(String name) &#123;</span><br><span class="line">            System.out.println(&quot;greet to &quot;+name+&quot;!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void serverTo(String name) &#123;</span><br><span class="line">            System.out.println(&quot;server to &quot;+name+&quot;!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码Seller：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.Advisor;</span><br><span class="line"></span><br><span class="line">public class Seller &#123;</span><br><span class="line">    public void greetTo(String name)&#123;</span><br><span class="line">        System.out.println(&quot;seller greet to&quot;+name+&quot;!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Seller和Waiter有相同的方法greetTo（），使用StaticMethodMatcherPointcutAdvisor定义一个切面，在Waiter#greetTo（）方法调用前织入一个增强。<br>切面类GreetingAdvisor：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.Advisor.StaticMethod;</span><br><span class="line"></span><br><span class="line">import com.Advisor.Waiter;</span><br><span class="line">import org.springframework.aop.ClassFilter;</span><br><span class="line">import org.springframework.aop.support.StaticMethodMatcherPointcutAdvisor;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class greetAdvisor extends StaticMethodMatcherPointcutAdvisor &#123;</span><br><span class="line">    public boolean matches(Method method, Class&lt;?&gt; aClass) &#123;</span><br><span class="line">        return &quot;greetTo&quot;.equals(method.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ClassFilter getClassFilter() &#123;//类别过滤器</span><br><span class="line">        return new ClassFilter() &#123;</span><br><span class="line">            public boolean matches(Class&lt;?&gt; aClass) &#123;</span><br><span class="line">                return Waiter.class.isAssignableFrom(aClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>StaticMethodMatcherPointcutAdvisor抽象类唯一需要实现的是matches（）方法。在默认的情况下匹配所有类，这里通过覆盖getClassFilter（）方法匹配Waiter类。<br>class1.isAssignableFrom(class2) 判定此 Class 对象所表示的类或接口与指定的 Class 参数所表示的类或接口是否相同，或是否是其超类或超接口。如果是则返回 true；否则返回 false。如果该 Class 表示一个基本类型，且指定的 Class 参数正是该 Class 对象，则该方法返回 true；否则返回 false。</p><p>配合Advisor的增强类GreeetingBeforeAdvice：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.Advisor.StaticMethod;</span><br><span class="line"></span><br><span class="line">import org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class greetBeforeAdvice implements MethodBeforeAdvice &#123;</span><br><span class="line">    public void before(Method method, Object[] objects, Object o) throws Throwable &#123;</span><br><span class="line">        System.out.println(o.getClass().getName()+&quot;.&quot;+method.getName()); //输出切点</span><br><span class="line">        String name=(String)objects[0];</span><br><span class="line">        System.out.println(&quot;How are you ! Mr&quot;+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用Spring配置来定义切面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 普通方法名匹配切面 --&gt;</span><br><span class="line">    &lt;bean id=&quot;waiterTarget&quot; class=&quot;com.Advisor.Waiter&quot; /&gt;</span><br><span class="line">    &lt;bean id=&quot;sellerTarget&quot; class=&quot;com.Advisor.Seller&quot; /&gt;</span><br><span class="line">    &lt;bean id=&quot;greetingAdvice&quot; class=&quot;com.Advisor.StaticMethod.greetBeforeAdvice&quot; /&gt; &lt;!--注入一个前置增强--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;greetingAdvisor&quot; class=&quot;com.Advisor.StaticMethod.greetAdvisor&quot;</span><br><span class="line">          p:advice-ref=&quot;greetingAdvice&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--通过一个父bean定义公共信息--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;parent&quot; abstract=&quot;true&quot;</span><br><span class="line">          class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span><br><span class="line">          p:interceptorNames=&quot;greetingAdvisor&quot; p:proxyTargetClass=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;bean id=&quot;waiter&quot; parent=&quot;parent&quot; p:target-ref=&quot;waiterTarget&quot; /&gt;</span><br><span class="line">    &lt;bean id=&quot;seller&quot; parent=&quot;parent&quot; p:target-ref=&quot;sellerTarget&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.Advisor;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">import org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line">public class StaticMethod &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void start()&#123;</span><br><span class="line">        ApplicationContext context=new ClassPathXmlApplicationContext(&quot;com/Advisor/StaticMethod.xml&quot;);</span><br><span class="line">        Waiter waiter=(Waiter) context.getBean(&quot;waiter&quot;);</span><br><span class="line">        Seller seller=(Seller)context.getBean(&quot;seller&quot;);</span><br><span class="line">        waiter.greetTo(&quot;wade0&quot;);</span><br><span class="line">        waiter.serverTo(&quot;wade&quot;);</span><br><span class="line">        seller.greetTo(&quot;wade&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com.Advisor.Waiter.greetTo</span><br><span class="line">How are you ! Mrwade0</span><br><span class="line">greet to wade0!</span><br><span class="line">server to wade!</span><br><span class="line">seller greet towade!</span><br></pre></td></tr></table></figure></p><p>可以发现Waiter.GreetTo（）方法被织入了增强，而Seller.GreetTo()方法没有织入增强。  </p><h3 id="流程切面"><a href="#流程切面" class="headerlink" title="流程切面"></a>流程切面</h3><p>Spring的流程切面由DefaultPointcutAdvisor和ControlFlowPointcut实现，流程切点代表某个方法直接或间接发起调用其他的方法。通过一个WaiterDelegate类代理Waiter所有方法.<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.Advisor;</span><br><span class="line"></span><br><span class="line">public class WaiterDelegate &#123;</span><br><span class="line">    private Waiter waiter;</span><br><span class="line"></span><br><span class="line">    public void service(String name)&#123;</span><br><span class="line">        waiter.greetTo(name);</span><br><span class="line">        waiter.serverTo(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWaiter(Waiter waiter) &#123;</span><br><span class="line">        this.waiter = waiter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果希望WaiterDelegate#Service（）方法发起调用的其他方法都织入了GreetingBeforeAdvice增强，就必须使用流程切面来完成。</p><p>配置控制流程切面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;greetingAdvice&quot; class=&quot;com.Advice.GreetingBeforeAdvice&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;waiterTarget&quot; class=&quot;com.Advisor.Waiter&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;controlFlowPointcut&quot; class=&quot;org.springframework.aop.support.ControlFlowPointcut&quot;&gt;</span><br><span class="line">        &lt;constructor-arg type=&quot;java.lang.Class&quot; value=&quot;com.Advisor.WaiterDelegate&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;service&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;controlFlowAdvisor&quot; class=&quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;</span><br><span class="line">          p:pointcut-ref=&quot;controlFlowPointcut&quot;</span><br><span class="line">          p:advice-ref=&quot;greetingAdvice&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;waiter3&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span><br><span class="line">          p:proxyTargetClass=&quot;true&quot;</span><br><span class="line">          p:target-ref=&quot;waiterTarget&quot;</span><br><span class="line">          p:interceptorNames=&quot;controlFlowAdvisor&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>ControlFlowPointcut有两个构造函数，分别是ControlFlowPointcut（Class clazz）和ControlFlowPointcut（Class clazz，String methodName），第一个构造函数制定一个类作为流程切点，第二个构造函数指定一个类和一个方法作为流程切点。<br>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.Advisor;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">import org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line">public class ControlFlow &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void control() &#123;</span><br><span class="line">        String configPath = &quot;com/Advisor/ControlFlow.xml&quot;;</span><br><span class="line">        ApplicationContext ctx = new ClassPathXmlApplicationContext(configPath);</span><br><span class="line">        Waiter waiter = (Waiter) ctx.getBean(&quot;waiter3&quot;);</span><br><span class="line">        WaiterDelegate wd = new WaiterDelegate();</span><br><span class="line">        wd.setWaiter(waiter);</span><br><span class="line">        waiter.serverTo(&quot;Peter&quot;);</span><br><span class="line">        waiter.greetTo(&quot;Peter&quot;);</span><br><span class="line">        wd.service(&quot;Peter&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server to Peter!</span><br><span class="line">greet to Peter!</span><br><span class="line">How are you! MrPeter!</span><br><span class="line">greet to Peter!</span><br><span class="line">How are you! MrPeter!</span><br><span class="line">server to Peter!</span><br></pre></td></tr></table></figure></p><p>可以看到一开始直接使用waiter的serverTo和greetTo方法都没有增强，而通过waiterDelegate中service方法调用waiter中的serverTo和greetTo即可。</p><h3 id="复合切点切面"><a href="#复合切点切面" class="headerlink" title="复合切点切面"></a>复合切点切面</h3><p>加入我们希望WaiterDelegate#service（）发起的调用且调用方法是greetTo时才织入增强，则这个切点就是复合切点，它由两个单独的切点确定。我们可以使用Spring提供的ComposablePointcut把两个切点组合起来。<br>Composable本身也是一个切点，实现了Pointcut接口。了解一下其构造函数：<br>ComposablePointcut() 构造一个匹配所有类所有方法的复合切点<br>ComposablePointcut(ClassFilter classFilter) 匹配特定类所有方法的复合切点<br>ComposablePointcut(MethodMatcher methodMatcher) 匹配所有类特定方法的切点<br>ComposablePointcut(ClassFilter classFilter,MethodMatcher methodMatcher) 匹配特定类特定方法的切点<br>交集复合的方法是：<br>ComposablePointcut intersection(ClassFilter classFilter) 将复合切点和一个ClassFilter对象进行交集运算，得到一个符合切点<br>ComposablePointcut intersection(MethodMatcher methodMatcher)  将复合切点和一个MethodMatcher对象进行交集运算，得到一个复合切点<br>ComposablePointcut intersection(Pointcut pointcut) 将复合切点和一个切点对象进行交集运算，得到一个复合切点<br>并集复合的方法是：<br>ComposablePointcut union(ClassFilter classFilter) 将复合切点和一个ClassFilter对象进行并集运算，得到一个符合切点<br>ComposablePointcut union(MethodMatcher methodMatcher) 将复合切点和一个MethodMatcher对象进行并集运算，得到一个符合切点<br>ComposablePointcut没有提供一个参数为Pointcut的union方法，可以使org.springframework.aop.support.Pointcuts工具类，有两个静态方法可以返回一个Pointcut这个Pointcut 正是ComposablePointcut。<br>Pointcut intersection(Pointcut a,Pointcut b) 两个切点交集运算<br>Pointcut union(Pointcut a,Pointcut b) 并集运算<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.Advisor.Composable;</span><br><span class="line"></span><br><span class="line">import com.Advisor.WaiterDelegate;</span><br><span class="line">import org.springframework.aop.Pointcut;</span><br><span class="line">import org.springframework.aop.support.ComposablePointcut;</span><br><span class="line">import org.springframework.aop.support.ControlFlowPointcut;</span><br><span class="line">import org.springframework.aop.support.NameMatchMethodPointcut;</span><br><span class="line"></span><br><span class="line">public class GreetingComposablePointcut &#123;</span><br><span class="line">    public Pointcut getIntersectionPointcut()&#123;</span><br><span class="line">        ComposablePointcut composablePointcut=new ComposablePointcut();//创建一个复合切点</span><br><span class="line"></span><br><span class="line">        Pointcut pointcut1=new ControlFlowPointcut(WaiterDelegate.class,&quot;service&quot;);//创建一个流程切点</span><br><span class="line"></span><br><span class="line">        NameMatchMethodPointcut pointcut2 =new NameMatchMethodPointcut();//创建一个方法名切点</span><br><span class="line"></span><br><span class="line">        pointcut2.addMethodName(&quot;greetTo&quot;);</span><br><span class="line"></span><br><span class="line">        return composablePointcut.intersection(pointcut1).intersection((Pointcut)pointcut2);//将两个切点进行交操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;waiterTaget&quot; class=&quot;com.Advisor.Waiter&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;greetingAdvice&quot; class=&quot;com.Advice.GreetingBeforeAdvice&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;gcp&quot; class=&quot;com.Advisor.Composable.GreetingComposablePointcut&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 复合切点切面--&gt;</span><br><span class="line">    &lt;bean id=&quot;composableAdvisor&quot; class=&quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;</span><br><span class="line">          p:pointcut=&quot;#&#123;gcp.intersectionPointcut&#125;&quot;</span><br><span class="line">          p:advice-ref=&quot;greetingAdvice&quot;/&gt; &lt;!--调用gcp中的getIntersectionPointcut()方法的到复合切点--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;waiter4&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span><br><span class="line">          p:interceptorNames=&quot;composableAdvisor&quot;</span><br><span class="line">          p:target-ref=&quot;waiterTaget&quot;</span><br><span class="line">          p:proxyTargetClass=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.Advisor;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">import org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line">public class Composable &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void composable()&#123;</span><br><span class="line">        String configPath = &quot;com/Advisor/Composable.xml&quot;;</span><br><span class="line">        ApplicationContext ctx = new ClassPathXmlApplicationContext(configPath);</span><br><span class="line">        Waiter waiter = (Waiter) ctx.getBean(&quot;waiter4&quot;);</span><br><span class="line">        WaiterDelegate wd = new WaiterDelegate();</span><br><span class="line">        wd.setWaiter(waiter);</span><br><span class="line">        waiter.serverTo(&quot;Peter&quot;);</span><br><span class="line">        waiter.greetTo(&quot;Peter&quot;);</span><br><span class="line">        wd.service(&quot;Peter&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server to Peter!</span><br><span class="line">greet to Peter!</span><br><span class="line">How are you! MrPeter!</span><br><span class="line">greet to Peter!</span><br><span class="line">server to Peter!</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Spring底层使用的JDK动态代理和GGLib动态代理，使用JDK动态代理目标类必须实现接口，而GGLib动态代理则不做任何要求，它通过动态生成目标子类的方式提供代理。<br>Spring只能在方法级别上织入增强，Spring提供了4种级别的方法增强，前置增强，后置增强，环绕增强，异常抛出增强。增强其实就是最简单的一种切面，既包括横切代码，有包括切点信息。只不过他的切点位置是最简单的方法相对位置信息，所以一般需要和切点联合才可以表示一个更具实用性的切面。<br>切点一般通过目标类名和方法名来定位连接点信息。需要通过切点的交叉合并可以使用CompasablePiontcut的复合切点。<br>切面是增强和切点的联合，可以通过Spring提供的ProxyBeanFactory将切面织入不同的目标类中。<br>往往在配置时先定义目标对象的Bean，即Target。然后定义增强类（Advice），在定义切点（pointcut），之后定义切面，织入切点与增强，然后创建ProxyFactoryBean代理的代理类Bean。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AOP&quot;&gt;&lt;a href=&quot;#AOP&quot; class=&quot;headerlink&quot; title=&quot;AOP&quot;&gt;&lt;/a&gt;AOP&lt;/h1&gt;&lt;p&gt;AOP是aspect oriented programing的简称，意为面向切面编程。有时候我们无法通过抽象父类消除重复性的横切代码，因为这些横切逻辑依赖在业务流程中，无法转移到另外的地方。AOP希望将这些分散在各个业务逻辑中的相同代码通过横向切割的方式抽取到独立的模块中，还业务逻辑类一个清新的世界。&lt;/p&gt;
&lt;h2 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;连接点（Joinpoint）：特定点是程序执行的某个位置，如类的开始初始化前，初始化后，类的某个方法调用前后，方法抛出异常后。一个类或者一段程序代码拥有的一些具有边界性质的特定点被成为连接点。Spring仅支持方法的连接点。使用切点对执行点定义，而方位则在增强类中定义。&lt;/li&gt;
&lt;li&gt;切点（Pointcut）：每个程序都有众多的连接点，连接点是客观存在的事务。在众多连接点中定位到我们需要的连接点就是切点。连接点相当于数据库中的记录，切点就是相当于条件查询。切点用过org.springframework.aop.Pointcut接口进行描述，使用类和方法进行作为连接点的查询条件，切点只定位到某方法上，如果需要确定到某连接点，还需要提供方位信息。&lt;/li&gt;
&lt;li&gt;增强（Advice）：增强是织入目标类连接点上的一段程序代码。增强除了用于描述一段代码外，还拥有一个和连接点相关的信息，这便是执行点的方位。所以增强接口都是带方位名的，如：BeforeAdvice，AfterReturningAdvice，ThThrowsAdvice等。只有结合切点增强，才能确定特定连接点的位置，并实施增强逻辑。&lt;/li&gt;
&lt;li&gt;目标对象（Target）：增强织入的目标类。&lt;/li&gt;
&lt;li&gt;引介（Introduction）：引介是一种特殊的增强，它可以为类添加属性和方法。&lt;/li&gt;
&lt;li&gt;织入（Weaving）:织入是将增强添加到目标类的具体连接点上。&lt;/li&gt;
&lt;li&gt;代理（Proxy）：一个类被AOP织入增强后，就产生了一个结果类，他是融合了原类和增强逻辑的代理类。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="study" scheme="http://yoursite.com/categories/study/"/>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Bean的配置</title>
    <link href="http://yoursite.com/2018/04/01/Spring-Bean-Load/"/>
    <id>http://yoursite.com/2018/04/01/Spring-Bean-Load/</id>
    <published>2018-04-01T03:21:20.000Z</published>
    <updated>2018-04-01T15:59:04.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bean的元数据信息"><a href="#Bean的元数据信息" class="headerlink" title="Bean的元数据信息"></a>Bean的元数据信息</h1><ul><li>Bean的实现类</li><li>Bean的属性信息(如数据源连接数,用户名,密码)</li><li>Bean的依赖关系,Spring根据依赖关系配置完成Bean之间的装配</li><li>Bean的行为配置如生命周期范围及生命周期各哥过程之间的回调</li></ul><a id="more"></a><h1 id="Spring依赖注入-DI"><a href="#Spring依赖注入-DI" class="headerlink" title="Spring依赖注入(DI)"></a>Spring依赖注入(DI)</h1><p><em>让调用类对某一接口实现类的依赖关系由第三方(容器或者协助类)注入,以移除调用类对某一接口实现类的依赖</em>  </p><p>Spring支持两中方式的依赖注入,属性注入和构造函数注入.</p><h2 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h2><p>属性注入通过setXXX()方法注入Bean的属性值或者依赖对象,<em>要求Bean提供一个默认的构造函数(不带参数的构造函数)</em>.Spring先调用Bean的默认构造函数实例化Bean对象,然后通过反射的方式调用Setter方法注入属性值.</p><p>textEditor:默认构造函数与Setter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.setter;</span><br><span class="line"></span><br><span class="line">public class textEditor &#123;</span><br><span class="line">    private sChecker spellChecker;</span><br><span class="line">    private int num;</span><br><span class="line"></span><br><span class="line">    //    public textEditor(sChecker spellChecker) &#123;</span><br><span class="line">//        System.out.println(&quot;Inside textEdotor Constructor&quot;);</span><br><span class="line">//        this.spellChecker = spellChecker;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNum() &#123;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNum(int num) &#123;</span><br><span class="line">        this.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SpellCheck()&#123;</span><br><span class="line">        spellChecker.checkSpelling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public sChecker getSpellChecker() &#123;</span><br><span class="line">        return spellChecker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSpellChecker(sChecker spellChecker) &#123;</span><br><span class="line">        this.spellChecker = spellChecker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>依赖类sChecker:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.setter;</span><br><span class="line"></span><br><span class="line">public class sChecker &#123;</span><br><span class="line">    public sChecker() &#123;</span><br><span class="line">        System.out.println(&quot;Inside SpellChecker Constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void checkSpelling()&#123;</span><br><span class="line">        System.out.println(&quot;inside checkSpelling&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.setter;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class MainAPP &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ApplicationContext context=new ClassPathXmlApplicationContext(&quot;com/setter/Bean.xml&quot;);</span><br><span class="line">        textEditor textEditor=(com.setter.textEditor)context.getBean(&quot;text&quot;);</span><br><span class="line">        textEditor.SpellCheck();</span><br><span class="line">        System.out.println(textEditor.getNum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!-- &lt;bean id=&quot;textEditor&quot; class=&quot;com.setter.textEditor&quot; p:spellChecker-ref=&quot;sChecker&quot;/&gt;  注意ID不可以重名!!!</span><br><span class="line">    --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;text&quot; class=&quot;com.setter.textEditor&quot; p:spellChecker-ref=&quot;sChecker&quot; p:num=&quot;10&quot;/&gt; &lt;!-- 通过Setter注入,需要实现默认构造函数--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;sChecker&quot; class=&quot;com.setter.sChecker&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inside SpellChecker Constructor</span><br><span class="line">inside checkSpelling</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p><h3 id="Javabean关于属性命名的规范"><a href="#Javabean关于属性命名的规范" class="headerlink" title="Javabean关于属性命名的规范"></a>Javabean关于属性命名的规范</h3><p>一般情况下Java属性变量是小写开头,如maxSpeed,如果要大写开头,在必须前两个字母全大写,如IDc,IDCard都是合法的.<br><em>变量的前两个字母要不全大写,要不全小写</em>,否则会报错.</p><h2 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h2><p>可以使用类型匹配与索引匹配,也可在情况较为复杂时联合使用  </p><p>具有两个构造函数的Bean:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.construct;</span><br><span class="line"></span><br><span class="line">public class textEditor &#123;</span><br><span class="line">    private SpellChecker spellChecker;</span><br><span class="line">    private int count;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public textEditor(SpellChecker spellChecker, int count, String message) &#123;</span><br><span class="line">        System.out.println(&quot;Three parameters&quot;);</span><br><span class="line">        this.spellChecker = spellChecker;</span><br><span class="line">        this.count = count;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public textEditor(SpellChecker spellChecker) &#123;</span><br><span class="line">        System.out.println(&quot;Inside textEdotor Constructor&quot;);</span><br><span class="line">        this.spellChecker = spellChecker;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;textEditor&#123;&quot; +</span><br><span class="line">                &quot;spellChecker=&quot; + spellChecker +</span><br><span class="line">                &quot;, count=&quot; + count +</span><br><span class="line">                &quot;, message=&apos;&quot; + message + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>依赖类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.construct;</span><br><span class="line"></span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line">    public SpellChecker() &#123;</span><br><span class="line">        System.out.println(&quot;Inside SpellChecker Constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void checkSpelling()&#123;</span><br><span class="line">        System.out.println(&quot;inside checkSpelling&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.construct;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class MainAPP &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ApplicationContext context=new ClassPathXmlApplicationContext(&quot;com/construct/Bean.xml&quot;);</span><br><span class="line">        textEditor textEditor=(com.construct.textEditor)context.getBean(&quot;textEditor&quot;);</span><br><span class="line">        System.out.println(textEditor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;textEditor&quot; class=&quot;com.construct.textEditor&quot; &gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;0&quot; ref=&quot;spellChecker&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;1&quot; value=&quot;1&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;2&quot; value=&quot;hey!&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--使用 index 属性来显式的指定构造函数参数的索引。(如果参数个数有构造函数相同,可以加上type来判别</span><br><span class="line">    如果你想要向一个对象传递一个引用，你需要使用 标签的 ref 属性，</span><br><span class="line">    如果你想要直接传递值，那么你应该使用如上所示的 value 属性--&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;spellChecker&quot; class=&quot;com.construct.SpellChecker&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inside SpellChecker Constructor</span><br><span class="line">Three parameters</span><br><span class="line">textEditor&#123;spellChecker=com.construct.SpellChecker@4d95d2a2, count=1, message=&apos;hey!&apos;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="注入集合"><a href="#注入集合" class="headerlink" title="注入集合"></a>注入集合</h2><p>Java.util中主要有一下常见集合:  </p><ul><li><list>:它有助于连线，如注入一列值，允许重复。</list></li><li><set>:它有助于连线一组值，但不能重复。</set></li><li><map>:它可以用来注入名称-值对的集合，其中名称和值可以是任何类型。</map></li><li><props>:它可以用来注入名称-值对的集合，其中名称和值都是字符串类型。</props></li></ul><p>一个含有常见集合的Bean:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package com.Collection;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Collections &#123;</span><br><span class="line">    private List list;</span><br><span class="line">    private Set set;</span><br><span class="line">    private Map map;</span><br><span class="line">    private Properties properties;//它可以用来注入名称-值对的集合，其中名称和值都是字符串类型。</span><br><span class="line"></span><br><span class="line">    public List getList() &#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setList(List list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Set getSet() &#123;</span><br><span class="line">        return set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSet(Set set) &#123;</span><br><span class="line">        this.set = set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map getMap() &#123;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMap(Map map) &#123;</span><br><span class="line">        this.map = map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Properties getProperties() &#123;</span><br><span class="line">        return properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProperties(Properties properties) &#123;</span><br><span class="line">        this.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Collections&#123;&quot; +</span><br><span class="line">                &quot;list=&quot; + list +</span><br><span class="line">                &quot;, set=&quot; + set +</span><br><span class="line">                &quot;, map=&quot; + map +</span><br><span class="line">                &quot;, properties=&quot; + properties +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.Collection;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class MainApp &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ApplicationContext context=new ClassPathXmlApplicationContext(&quot;com/Collection/Bean.xml&quot;);</span><br><span class="line"></span><br><span class="line">        Collections collections=(Collections)context.getBean(&quot;Collection&quot;);</span><br><span class="line">        System.out.println(collections);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collections&#123;list=[watermelon, apple, banana], </span><br><span class="line">set=[watermelon, apple, banana], </span><br><span class="line">map=&#123;1=watermelon, watermelon=du, Richard=Lee&#125;, </span><br><span class="line">properties=&#123;two=Pakistan, one=INDIA, three=USA, four=USA&#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h1><ul><li>no:这是默认的设置，它意味着没有自动装配，你应该使用显式的bean引用来连线。你不用为了连线做特殊的事。在依赖注入章节你已经看到这个了。</li><li>byName:由属性名自动装配。Spring 容器看到在 XML 配置文件中 bean 的自动装配的属性设置为 byName。然后尝试匹配，并且将它的属性与在配置文件中被定义为相同名称的 beans 的属性进行连接。</li><li>byType:由属性数据类型自动装配。Spring 容器看到在 XML 配置文件中 bean 的自动装配的属性设置为 byType。然后如果它的类型匹配配置文件中的一个确切的 bean 名称，它将尝试匹配和连接属性的类型。如果存在不止一个这样的 bean，则一个致命的异常将会被抛出。</li><li>constructor:类似于 byType，但该类型适用于构造函数参数类型。如果在容器中没有一个构造函数参数类型的 bean，则一个致命错误将会发生。</li><li>autodetect:Spring首先尝试通过 constructor 使用自动装配来连接，如果它不执行，Spring 尝试通过 byType 来自动装配。</li></ul><p><em>在实际开发中,XML配置方式很少启用自动装配功能,而基于注解的配置方式默认采用bytype自动装配策略</em></p><h1 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h1><h2 id="使用注解定义Bean"><a href="#使用注解定义Bean" class="headerlink" title="使用注解定义Bean"></a>使用注解定义Bean</h2><p>Spring容器启动的三大要素是bean的定义信息,bean的实现类以及Spring本身,采用XML配置,Bean的定义和Bean的实现类是分离的;如果采用配置文件,Bean的定义信息是通过Bean实现类上标注注解实现.<br>下面是一个注解定义DAO的Bean:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.Dao</span><br><span class="line"></span><br><span class="line">import org.springframework.sterotype.Component</span><br><span class="line">//通过@Component定义一个DAO的Bean</span><br><span class="line">@Component(&quot;userDao&quot;)</span><br><span class="line">public void UserDao&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面使用@Component注解在UserDao类声明处标注,使它可以被Spring识别,Spring容器自动将POJO转化为容器管理的Bean.<br>等价于下列XML配置:<br><code>&lt;bean id=&quot;userDao&quot; class=&quot;com.Dao.UserDao&quot;/&gt;</code><br>除了@Component外,Spring还提供了3个基本功能和@Component等效的注解:</p><ul><li>@Repository:用于对DAO实现类进行标注</li><li>@Service:对Service实现类标注</li><li>@Controller:对Controller实现类标注<br>这三个注解完全实现了@Component的功能,推荐使用,使我们编程可以一眼看出Bean的身份.</li></ul><h2 id="扫描注解定义的Bean"><a href="#扫描注解定义的Bean" class="headerlink" title="扫描注解定义的Bean"></a>扫描注解定义的Bean</h2><p>需要在XMl文件中使用命名空间context:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans </span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd </span><br><span class="line">       http://www.springframework.org/schema/context </span><br><span class="line">       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.autowired&quot;/&gt;</span><br><span class="line">    &lt;!-- 扫描类包以应用注解的bean--&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><h2 id="自动装配Bean"><a href="#自动装配Bean" class="headerlink" title="自动装配Bean"></a>自动装配Bean</h2><h3 id="使用-Autowired"><a href="#使用-Autowired" class="headerlink" title="使用@Autowired"></a>使用@Autowired</h3><p>使用@Autowired来实现自动注入,required=false属性表示即使容器中没有没有一个和标注类型匹配的Bean,Spring容器也不要抛出NoSuchBeanDefinitionException异常.</p><p>实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class LogonService&#123;</span><br><span class="line">    @Autowired(required=false)</span><br><span class="line">    private LogDao logDao;</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用@Service标注一个Bean,通过@Autowired注入LogDao的Bean,@Autowired默认按照Bean的类型来装配Bean.</p><h3 id="使用-Qualifier指定注入Bean的名称"><a href="#使用-Qualifier指定注入Bean的名称" class="headerlink" title="使用@Qualifier指定注入Bean的名称"></a>使用@Qualifier指定注入Bean的名称</h3><p>当容器中有一个以上匹配的Bean,可以通过@Qualifier注解限定注入Bean的名称.</p><p>实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class LogonService&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;userDao&quot;)// 注入名为userDao,类型为UserDao的Bean</span><br><span class="line">    private UserDao userDao;</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>加入有两个类型为UserDao的Bean,一个叫UserDao,一个叫otheruserDao,则我们最后通过@Qualifier注入userDao.  </p><h3 id="对类方法进行标注"><a href="#对类方法进行标注" class="headerlink" title="对类方法进行标注"></a>对类方法进行标注</h3><p>@Autowired可以对类方法以及方法的参数进行标注</p><p>实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">   @Qualifier(&quot;userDao&quot;)</span><br><span class="line">   public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">       System.out.println(&quot;auto inject&quot;);</span><br><span class="line">       this.userDao = userDao;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Autowired</span><br><span class="line">   public void setLogDao(LogDao logDao) &#123;</span><br><span class="line">       this.logDao = logDao;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>如果一个方法有多个参数需要标记,默认情况下Spring自动选择匹配类型进行注入.也可使用@Qualifier指定注入  </p><pre><code>@Autowired       public void init(@Qualifier(&quot;userDao&quot;)UserDao userDao,LogDao logDao){           System.out.println(&quot;multi param inject&quot;);           this.userDao = userDao;           this.logDao =logDao;       }</code></pre><p><em>实际开发中建议在方法上标注@Autowired,这样更加”面向对象”,也方便测试的编写.</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Bean的元数据信息&quot;&gt;&lt;a href=&quot;#Bean的元数据信息&quot; class=&quot;headerlink&quot; title=&quot;Bean的元数据信息&quot;&gt;&lt;/a&gt;Bean的元数据信息&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Bean的实现类&lt;/li&gt;
&lt;li&gt;Bean的属性信息(如数据源连接数,用户名,密码)&lt;/li&gt;
&lt;li&gt;Bean的依赖关系,Spring根据依赖关系配置完成Bean之间的装配&lt;/li&gt;
&lt;li&gt;Bean的行为配置如生命周期范围及生命周期各哥过程之间的回调&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="study" scheme="http://yoursite.com/categories/study/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-IoC学习笔记</title>
    <link href="http://yoursite.com/2018/03/30/Spring-IoC/"/>
    <id>http://yoursite.com/2018/03/30/Spring-IoC/</id>
    <published>2018-03-30T05:58:19.000Z</published>
    <updated>2018-03-31T02:47:40.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringIoC"><a href="#SpringIoC" class="headerlink" title="SpringIoC"></a>SpringIoC</h1><h2 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h2><p>ioc(Inverse of Control)是Spring容器的内核.控制反转即某一接口具体实现类的选择控制权从调用类移除,交由第三方决定,即由Spring容器借由bean配置来控制.  </p><p>Spring提供了两种类型的容器:  </p><ul><li>Beanfactory:创建管理各个类的对象.</li><li>ApplicationContext:由benefactory派生来,面向spring的所有开发者,几乎所有场合都可以使用,而非使用底层的Beanfactory.</li></ul><a id="more"></a><h3 id="使用beanfactory"><a href="#使用beanfactory" class="headerlink" title="使用beanfactory"></a>使用beanfactory</h3><p>BeanFactory主要实现方法是XmlBeanfactory,但现在已经是被废弃的方法,不建议使用,使用XmlBeanDefinitionReader与DefaultListableBeanFactory.<br>XmlBeanDefinitionReader通过Resource装载Spring配置信息,启动IoC容器,,然后就可以通过BeanFactory#getBean(ByName)来从IoC容器中获取Bean.  </p><h4 id="创建bean"><a href="#创建bean" class="headerlink" title="创建bean:"></a>创建bean:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.Beanfactory;</span><br><span class="line"></span><br><span class="line">public class Hello &#123;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void getMessage() &#123;</span><br><span class="line">        System.out.println(&quot;Message:&quot; + message); ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置bean"><a href="#配置bean" class="headerlink" title="配置bean:"></a>配置bean:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;helloWorld&quot; class=&quot;com.Beanfactory.Hello&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;message&quot; value=&quot;Hello World!&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试:"></a>测试:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.Beanfactory;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.support.DefaultListableBeanFactory;</span><br><span class="line">import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;</span><br><span class="line">import org.springframework.beans.factory.xml.XmlBeanFactory;</span><br><span class="line">import org.springframework.core.io.ClassPathResource;</span><br><span class="line"></span><br><span class="line">public class MainApp &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">       /* XmlBeanFactory factory=new XmlBeanFactory(new ClassPathResource(&quot;com/Beanfactory/Bean.xml&quot;));</span><br><span class="line">       ClassPathResource:访问类路径下的资源,以相对于类路径的方式访问.(访问main/resources文件夹下的静态资源文件.)</span><br><span class="line">       */</span><br><span class="line">        DefaultListableBeanFactory factory=new DefaultListableBeanFactory();</span><br><span class="line">        XmlBeanDefinitionReader reader=new XmlBeanDefinitionReader(factory);</span><br><span class="line">        reader.loadBeanDefinitions(new ClassPathResource(&quot;com/Beanfactory/Bean.xml&quot;));</span><br><span class="line">       </span><br><span class="line">        //初始化BeanFactory时必须要提供一种日志框架,使用Log4j即可,将其放在类路径(resources静态资源文件夹)中,启动Spring容器变不会报错.</span><br><span class="line">        Hello hello=(Hello)factory.getBean(&quot;helloWorld&quot;);</span><br><span class="line">        hello.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用ApplicationContext"><a href="#使用ApplicationContext" class="headerlink" title="使用ApplicationContext"></a>使用ApplicationContext</h3><p>ApplicationContext主要是实现类是FileSystemXmlApplicationContext和ClassPathXmlApplicationContext.前者默认从文件系统装载配置文件,后者默认从类路径加载配置文.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext初始化与Beanfactory类似:</span><br><span class="line">     ApplicationContext context=new FileSystemXmlApplicationContext(&quot;/src/main/resources/com/ApplicationContext/Bean.xml&quot;);</span><br><span class="line">        //实际访问路径是/home/watermelon/JavaWebDemo/helloworld/src/main/resources/com/ApplicationContext/Bean.xml</span><br></pre></td></tr></table></figure></p><h3 id="WebApplicatpnContext"><a href="#WebApplicatpnContext" class="headerlink" title="WebApplicatpnContext"></a>WebApplicatpnContext</h3><p>WebApplication是专门为web应用准备的,他允许相对于web更目录的路径加载配置文件的信息完成初始工作.从WebApplicationContext中可以获得ServletContext的引用,整个web应用上下文对象都可以将作为属性放置到ServletContext中,以便web应用环境可以访问Spring应用上下文.<br>web应用下bean的属性由非web应用下的singleton,prototype增加了request,session,global session.<br>可以通过以下语句获得WebApplicationContext:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WebApplicationContext context=(WebApplicationContext)servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</span><br><span class="line">//或者</span><br><span class="line">WebApplicationContext webApplicationContext=ContextLoader.getCurrentWebApplicationContext();    </span><br><span class="line">      ServletContext servletContext = webApplicationContext.getServletContext();</span><br></pre></td></tr></table></figure></p><h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>bean 的对象是构成应用程序的支柱也是由 Spring IoC 容器管理的。bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。  </p><p>bean的属性:</p><ul><li>class:这个属性是强制性的，并且指定用来创建 bean 的 bean 类。  </li><li>name:这个属性指定唯一的 bean 标识符。在基于 XML 的配置元数据中，你可以使用 ID 和/或 name 属性来指定 bean 标识符。  </li><li>scope:这个属性指定由特定的 bean 定义创建的对象的作用域。  </li><li>constructor-arg:用来注入依赖关系的。  </li><li>properties:用来注入依赖关系的，并会在接下来的章节中进行讨论。  </li><li>autowiring mode:用来注入依赖关系的，并会在接下来的章节中进行讨论。  </li><li>lazy-initialization mode:延迟初始化的 bean 告诉 IoC 容器在它第一次被请求时，而不是在启动时去创建一个 bean 实例。  </li><li>initialization:在 bean 的所有必需的属性被容器设置之后，调用回调方法。</li><li>destruction:当包含该 bean 的容器被销毁时，使用回调方法. </li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li>singleton:该作用域将 bean 的定义的限制在每一个 Spring IoC 容器中的一个单一实例(默认)。</li><li>prototype:该作用域将单一 bean 的定义限制在任意数量的对象实例。</li><li>request:该作用域将 bean 的定义限制为 HTTP 请求。只在 web-aware Spring ApplicationContext 的上下文中有效。</li><li>session:该作用域将 bean 的定义限制为 HTTP 会话。 只在web-aware Spring ApplicationContext的上下文中有效。</li><li>global-session:该作用域将 bean 的定义限制为全局 HTTP 会话。只在 web-aware Spring ApplicationContext 的上下文中有效。</li></ul><p>Singleton与prototype的区别:<br>在SpringIoC容器中,singleton类型的bean只会实例化一次,所以只有一个实例,当你以后getBean()时,得到的bean都是指向同一个实例.当你改变了其中的某些属性,则以后获得的bean都是被改变了的.<br>而prototype作用域的bean在每次获取时都会被实例化,则每次获得的都是不同的实例,当你改变了其中一个获得的实例,并不会对以后geaBean()有影响.</p><p>##3 生命周期</p><p><img src="../../../../img/Spring/bean-lifetime.png" alt="生命周期"><br>BeanFactory中的bean生命周期比ApplicationContext中的少调用了第一个BeanFactorPostProcessor</p><p>一个实例:<br>创建一个POJO,实现了BeanFactoryAware, BeanNameAware, InitializingBean, DisposableBean.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">package com.bean_lifetime;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.factory.BeanFactory;</span><br><span class="line">import org.springframework.beans.factory.BeanFactoryAware;</span><br><span class="line">import org.springframework.beans.factory.BeanNameAware;</span><br><span class="line">import org.springframework.beans.factory.DisposableBean;</span><br><span class="line">import org.springframework.beans.factory.InitializingBean;</span><br><span class="line"></span><br><span class="line">public class Car implements BeanFactoryAware, BeanNameAware, InitializingBean, DisposableBean &#123;</span><br><span class="line">private String brand;</span><br><span class="line">private String color;</span><br><span class="line">private int maxSpeed;</span><br><span class="line">private String name;</span><br><span class="line">private BeanFactory beanFactory;</span><br><span class="line">private String beanName;</span><br><span class="line"></span><br><span class="line">public Car() &#123;</span><br><span class="line">System.out.println(&quot;调用Car()构造函数。&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getBrand() &#123;</span><br><span class="line">return brand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setBrand(String brand) &#123;</span><br><span class="line">System.out.println(&quot;调用setBrand()设置属性。&quot;);</span><br><span class="line">this.brand = brand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getColor() &#123;</span><br><span class="line">return color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;brand:&quot; + brand + &quot;/color:&quot; + color + &quot;/maxSpeed:&quot;+ maxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setColor(String color) &#123;</span><br><span class="line">this.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getMaxSpeed() &#123;</span><br><span class="line">return maxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMaxSpeed(int maxSpeed) &#123;</span><br><span class="line">this.maxSpeed = maxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void introduce()&#123;</span><br><span class="line">System.out.println(&quot;introduce:&quot;+this.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// BeanFactoryAware接口方法</span><br><span class="line">public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">System.out.println(&quot;调用BeanFactoryAware.setBeanFactory()。&quot;);</span><br><span class="line">this.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BeanNameAware接口方法</span><br><span class="line">public void setBeanName(String beanName) &#123;</span><br><span class="line">System.out.println(&quot;调用BeanNameAware.setBeanName()。&quot;);</span><br><span class="line">this.beanName = beanName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// InitializingBean接口方法</span><br><span class="line">public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">System.out.println(&quot;调用InitializingBean.afterPropertiesSet()。&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DisposableBean接口方法</span><br><span class="line">public void destroy() throws Exception &#123;</span><br><span class="line">System.out.println(&quot;调用DisposableBean.destory()。&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void myInit() &#123;</span><br><span class="line">System.out.println(&quot;调用myInit()，将maxSpeed设置为240。&quot;);</span><br><span class="line">this.maxSpeed = 240;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void myDestory() &#123;</span><br><span class="line">System.out.println(&quot;调用myDestroy()。&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现BeanPostProcessor:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.bean_lifetime;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line">//在该类中可对bean的属性进行检查,执行相应的&quot;查漏补缺&quot;</span><br><span class="line">public class MyBeanPostProcessor implements BeanPostProcessor&#123;</span><br><span class="line"></span><br><span class="line">public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">if(beanName.equals(&quot;car&quot;))&#123;</span><br><span class="line">Car car = (Car)bean;</span><br><span class="line">if(car.getMaxSpeed() &gt;= 200)&#123;</span><br><span class="line">System.out.println(&quot;调用MyBeanPostProcessor.postProcessAfterInitialization()，将maxSpeed调整为200。&quot;);</span><br><span class="line">car.setMaxSpeed(200);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return bean;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">if(beanName.equals(&quot;car&quot;))&#123;</span><br><span class="line">Car car = (Car)bean;</span><br><span class="line">if(car.getColor() == null)&#123;</span><br><span class="line">System.out.println(&quot;调用MyBeanPostProcessor.postProcessBeforeInitialization()，color为空，设置为默认黑色。&quot;);</span><br><span class="line">car.setColor(&quot;黑色&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现InstantiationAwareBeanPostProcessor:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.bean_lifetime;</span><br><span class="line"></span><br><span class="line">import java.beans.PropertyDescriptor;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.PropertyValues;</span><br><span class="line">import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;</span><br><span class="line"></span><br><span class="line">public class MyInstantiationAwareBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter&#123;</span><br><span class="line"></span><br><span class="line">//接口方法,在实例化bean前调用</span><br><span class="line">public Object postProcessBeforeInstantiation(Class beanClass, String beanName) throws BeansException &#123;</span><br><span class="line">if(&quot;car&quot;.equals(beanName))&#123;//只对容器中 car 处理</span><br><span class="line">System.out.println(&quot;MyInstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">//接口方法,在实例化bean后调用</span><br><span class="line">public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">if(&quot;car&quot;.equals(beanName))&#123;//只对容器中 car 处理</span><br><span class="line">System.out.println(&quot;InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在设置某个属性的时候调用</span><br><span class="line">public PropertyValues postProcessPropertyValues(</span><br><span class="line">PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span><br><span class="line">throws BeansException &#123;</span><br><span class="line">if(&quot;car&quot;.equals(beanName))&#123;//只对容器中 car 处理,只处理某个特定属性</span><br><span class="line">   System.out.println(&quot;InstantiationAwareBeanPostProcessor.postProcessPropertyValues&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return pvs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">return bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">return bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现BeanFactoryPostProcessor(仅ApplicationContext中的bean才有的生命周期):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.bean_lifetime;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.factory.config.BeanDefinition;</span><br><span class="line">import org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span><br><span class="line">import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line"></span><br><span class="line">//仅在ApplicationContext的bean生命周期中</span><br><span class="line">public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor&#123;</span><br><span class="line"></span><br><span class="line">public void postProcessBeanFactory(ConfigurableListableBeanFactory bf) throws BeansException &#123;</span><br><span class="line">//更改bean的属性</span><br><span class="line">BeanDefinition bd = bf.getBeanDefinition(&quot;car&quot;);</span><br><span class="line">bd.getPropertyValues().addPropertyValue(&quot;brand&quot;, &quot;奇瑞QQ&quot;);</span><br><span class="line">System.out.println(&quot;调用MyBeanFactoryPostProcessor.postProcessBeanFactory()！&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后的分别用Beanfactory与ApplicationContext容器装载bean:</p><blockquote><p>ApplicationContext与Beanfactory有一个很大的区别在于:前者可以利用java反射机制自动识别配置文件中定义的BeanPostProcessor,InstantiationAwareBeanPostProcessor的BeanFactoryPostProcessor,并将他们注册到应用上下文中.而后者需要手工调用addBeanPostProcessor()方法,所以推荐使用APplicationContext容器来装载Bean.</p></blockquote><p>BeanFactory:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package com.bean_lifetime;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.BeanFactory;</span><br><span class="line">import org.springframework.beans.factory.config.ConfigurableBeanFactory;</span><br><span class="line">import org.springframework.beans.factory.support.DefaultListableBeanFactory;</span><br><span class="line">import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;</span><br><span class="line">import org.springframework.core.io.ClassPathResource;</span><br><span class="line">import org.springframework.core.io.Resource;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class BeanLifeCycle_beanfactory &#123;</span><br><span class="line">    private static void LifeCycleInBeanFactory()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       //①下面两句装载配置文件并启动容器</span><br><span class="line">    Resource res = new ClassPathResource(&quot;com/bean_lifetime/Bean.xml&quot;);</span><br><span class="line"></span><br><span class="line">       BeanFactory bf= new DefaultListableBeanFactory();</span><br><span class="line">       XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader((DefaultListableBeanFactory)bf);</span><br><span class="line">       reader.loadBeanDefinitions(res);</span><br><span class="line"></span><br><span class="line">       //②向容器中注册MyBeanPostProcessor后处理器</span><br><span class="line">       ((ConfigurableBeanFactory)bf).addBeanPostProcessor(new MyBeanPostProcessor());</span><br><span class="line"></span><br><span class="line">       //③向容器中注册MyInstantiationAwareBeanPostProcessor后处理器</span><br><span class="line">       ((ConfigurableBeanFactory)bf).addBeanPostProcessor(</span><br><span class="line">               new MyInstantiationAwareBeanPostProcessor());</span><br><span class="line">       //④第一次从容器中获取car，将触发容器实例化该Bean，这将引发Bean生命周期方法的调用。</span><br><span class="line">       Car car1 = (Car)bf.getBean(&quot;car&quot;);</span><br><span class="line">       car1.introduce();</span><br><span class="line">       car1.setColor(&quot;红色&quot;);</span><br><span class="line"></span><br><span class="line">       //⑤第二次从容器中获取car，直接从缓存池中获取</span><br><span class="line">       Car car2 = (Car)bf.getBean(&quot;car&quot;);</span><br><span class="line"></span><br><span class="line">       //⑥查看car1和car2是否指向同一引用</span><br><span class="line">       System.out.println(&quot;car1==car2:&quot;+(car1==car2));</span><br><span class="line">       //⑦关闭容器</span><br><span class="line">       ((DefaultListableBeanFactory)bf).destroySingletons();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">LifeCycleInBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">输出  </span><br><span class="line">MyInstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</span><br><span class="line">调用Car()构造函数。</span><br><span class="line">InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation</span><br><span class="line">InstantiationAwareBeanPostProcessor.postProcessPropertyValues</span><br><span class="line">调用setBrand()设置属性。</span><br><span class="line">调用BeanNameAware.setBeanName()。</span><br><span class="line">调用BeanFactoryAware.setBeanFactory()。</span><br><span class="line">调用MyBeanPostProcessor.postProcessBeforeInitialization()，color为空，设置为默认黑色。</span><br><span class="line">调用InitializingBean.afterPropertiesSet()。</span><br><span class="line">调用myInit()，将maxSpeed设置为240。</span><br><span class="line">调用MyBeanPostProcessor.postProcessAfterInitialization()，将maxSpeed调整为200。</span><br><span class="line">introduce:brand:奔驰/color:黑色/maxSpeed:200</span><br><span class="line">car1==car2:true</span><br><span class="line">调用DisposableBean.destory()。</span><br><span class="line">调用myDestroy()。</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>ApplicationContext:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.bean_lifetime;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.support.AbstractApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class BeanLifeCycle_applicationcontext &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        AbstractApplicationContext context=new ClassPathXmlApplicationContext(&quot;com/bean_lifetime/Bean.xml&quot;);</span><br><span class="line">        Car car1=(Car)context.getBean(&quot;car&quot;);</span><br><span class="line">        car1.introduce();</span><br><span class="line">        car1.setColor(&quot;蓝色&quot;);</span><br><span class="line"></span><br><span class="line">        Car car2=(Car)context.getBean(&quot;car&quot;);//再次获取car,直接在缓存池中获取</span><br><span class="line"></span><br><span class="line">        car2.introduce();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Car1==Car2?:&quot;+(car1==car2));</span><br><span class="line"></span><br><span class="line">        //context.destroy(); 也可以</span><br><span class="line">        context.registerShutdownHook();</span><br><span class="line">        /*</span><br><span class="line">        需要注册一个在 AbstractApplicationContext 类中声明的关闭 hook 的 registerShutdownHook() 方法。</span><br><span class="line">        它将确保正常关闭，并且调用相关的 destroy 方法。</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    输出:  </span><br><span class="line">    调用MyBeanFactoryPostProcessor.postProcessBeanFactory()！</span><br><span class="line">    调用Car()构造函数。</span><br><span class="line">    调用setBrand()设置属性。</span><br><span class="line">    调用BeanNameAware.setBeanName()。</span><br><span class="line">    调用BeanFactoryAware.setBeanFactory()。</span><br><span class="line">    调用MyBeanPostProcessor.postProcessBeforeInitialization()，color为空，设置为默认黑色。</span><br><span class="line">    调用InitializingBean.afterPropertiesSet()。</span><br><span class="line">    调用myInit()，将maxSpeed设置为240。</span><br><span class="line">    调用MyBeanPostProcessor.postProcessAfterInitialization()，将maxSpeed调整为200。</span><br><span class="line">    introduce:brand:奇瑞QQ/color:黑色/maxSpeed:200</span><br><span class="line">    introduce:brand:奇瑞QQ/color:蓝色/maxSpeed:200</span><br><span class="line">    Car1==Car2?:true</span><br><span class="line">    Closing org.springframework.context.support.ClassPathXmlApplicationContext@368102c8: startup date [Sat Mar 31 10:38:43 CST 2018]; root of context hierarchy</span><br><span class="line">    调用DisposableBean.destory()。</span><br><span class="line">    调用myDestroy()</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Xml配置文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;car&quot; class=&quot;com.bean_lifetime.Car&quot; init-method=&quot;myInit&quot; destroy-method=&quot;myDestory&quot; p:brand=&quot;奔驰&quot; p:maxSpeed=&quot;200&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;myBeanPostProcessor&quot; class=&quot;com.bean_lifetime.MyBeanPostProcessor&quot;/&gt; &lt;!--注册bean后处理器--&gt;</span><br><span class="line">    &lt;bean id=&quot;myBeanFactoryPostProcessor&quot; class=&quot;com.bean_lifetime.MyBeanFactoryPostProcessor&quot;/&gt; &lt;!--注册工厂后处理器--&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><h2 id="待办"><a href="#待办" class="headerlink" title="待办"></a>待办</h2><p>对于Java反射机制还需仔细了解</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringIoC&quot;&gt;&lt;a href=&quot;#SpringIoC&quot; class=&quot;headerlink&quot; title=&quot;SpringIoC&quot;&gt;&lt;/a&gt;SpringIoC&lt;/h1&gt;&lt;h2 id=&quot;IoC容器&quot;&gt;&lt;a href=&quot;#IoC容器&quot; class=&quot;headerlink&quot; title=&quot;IoC容器&quot;&gt;&lt;/a&gt;IoC容器&lt;/h2&gt;&lt;p&gt;ioc(Inverse of Control)是Spring容器的内核.控制反转即某一接口具体实现类的选择控制权从调用类移除,交由第三方决定,即由Spring容器借由bean配置来控制.  &lt;/p&gt;
&lt;p&gt;Spring提供了两种类型的容器:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Beanfactory:创建管理各个类的对象.&lt;/li&gt;
&lt;li&gt;ApplicationContext:由benefactory派生来,面向spring的所有开发者,几乎所有场合都可以使用,而非使用底层的Beanfactory.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="study" scheme="http://yoursite.com/categories/study/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>天津旅游计划</title>
    <link href="http://yoursite.com/2018/03/30/tianjin-plan/"/>
    <id>http://yoursite.com/2018/03/30/tianjin-plan/</id>
    <published>2018-03-30T03:23:10.000Z</published>
    <updated>2018-04-04T13:28:12.601Z</updated>
    
    <content type="html"><![CDATA[<p>清明4-7到4-8,和远远天津玩耍&gt;!&lt;<br><a id="more"></a></p><h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><p><img src="../../../../img/tianjin/dayone.png" alt="day-one">  </p><h1 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h1><p><img src="../../../../img/tianjin/daytwo.png" alt="day-two">  </p><h1 id="出发"><a href="#出发" class="headerlink" title="出发:"></a>出发:</h1><p>北京理工大学-&gt;北京南站 43分钟  4号线 12站<br>7点起床,七点半出门,8点半到</p><h1 id="饮食"><a href="#饮食" class="headerlink" title="饮食"></a>饮食</h1><h2 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h2><ul><li>炸酱面</li><li>饺子</li><li>皮皮虾</li><li>煎饼果子<br>##第一天:</li><li>五大道:桂圆餐厅(很火)</li><li>五大道 华竹食府(花生糊,土豆泥好)</li><li>南市食品街:耳朵眼炸糕</li><li>南市食品街:二姑包子</li><li></li></ul><h1 id="住处"><a href="#住处" class="headerlink" title="住处"></a>住处</h1><p>泡泡主题馆,南市食品街-住处:855/628 2元</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;清明4-7到4-8,和远远天津玩耍&amp;gt;!&amp;lt;&lt;br&gt;
    
    </summary>
    
      <category term="travel" scheme="http://yoursite.com/categories/travel/"/>
    
    
      <category term="tianjin" scheme="http://yoursite.com/tags/tianjin/"/>
    
  </entry>
  
  <entry>
    <title>Spring-sketch</title>
    <link href="http://yoursite.com/2018/03/29/Spring-sketch/"/>
    <id>http://yoursite.com/2018/03/29/Spring-sketch/</id>
    <published>2018-03-29T01:54:10.000Z</published>
    <updated>2018-03-30T03:28:58.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring基础理论"><a href="#Spring基础理论" class="headerlink" title="Spring基础理论"></a>Spring基础理论</h1><h2 id="Spring体系结构"><a href="#Spring体系结构" class="headerlink" title="Spring体系结构"></a>Spring体系结构</h2><p><img src="../../../../img/Spring/arch1.png" alt="Spring体系结构"><br><a id="more"></a><br>Spring框架大致分为5个模块,从持久层,业务层到展现层都提供了相应的技术支持.IoC与AOP是Spring所依赖的根本.  </p><p>1.IoC<br>它将类与类之间的依赖从代码中脱离,用配置的方式进行依赖关系的描述,有IoC容器进行类之间的创建,拼接,管理,获取等工作.<br>2.AOP<br>横切逻辑编程思想.将分散在各个业务逻辑中的相同代码通过很横切的方式抽取到独立的模块中,使业务逻辑类更为独立简洁.</p><h2 id="HelloWorld实例入门"><a href="#HelloWorld实例入门" class="headerlink" title="HelloWorld实例入门"></a>HelloWorld实例入门</h2><h3 id="创建源文件"><a href="#创建源文件" class="headerlink" title="创建源文件"></a>创建源文件</h3><p>Hello.java:<br>    package com.helloWorld;</p><p>public class Hello {<br>    private String message;</p><pre><code>public void setMessage(String message) {    this.message = message;}public void getMessage() {   System.out.println(&quot;Message:&quot; + message); ;}</code></pre><p>}</p><p>MainApp.java:<br>    package com.helloWorld;</p><p>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;</p><p>public class MainApp {<br>    public static void main(String[] args){<br>        ApplicationContext context=new ClassPathXmlApplicationContext(“com/helloWorld/Bean.xml”);<br>        Hello hello=(Hello) context.getBean(“helloWorld”);<br>        hello.getMessage();<br>    }<br>}</p><p>关于主要程序有以下两个要点需要注意：</p><pre><code>1.第一步是我们使用框架 API ClassPathXmlApplicationContext() 来创建应用程序的上下文。这个 API 加载 beans 的配文件并最终基于所提供的 API，它处理创建并初始化所有的对象，即在配置文件中提到的 beans。2.第二步是使用已创建的上下文的 getBean() 方法来获得所需的 bean。这个方法使用 bean 的 ID 返回一个最终可以转换为实际对象的通用对象。一旦有了对象，你就可以使用这个对象调用任何类的  </code></pre><p>###创建Bean配置文件</p><blockquote><p>静态文件建立在resources文件中对应的包中<br>代码:<br>    &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p></blockquote><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"><br><br>    <bean id="helloWorld" class="com.helloWorld.Hello"><br>        <property name="message" value="Hello World!"><br>    </property></bean><br></beans>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring基础理论&quot;&gt;&lt;a href=&quot;#Spring基础理论&quot; class=&quot;headerlink&quot; title=&quot;Spring基础理论&quot;&gt;&lt;/a&gt;Spring基础理论&lt;/h1&gt;&lt;h2 id=&quot;Spring体系结构&quot;&gt;&lt;a href=&quot;#Spring体系结构&quot; class=&quot;headerlink&quot; title=&quot;Spring体系结构&quot;&gt;&lt;/a&gt;Spring体系结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;../../../../img/Spring/arch1.png&quot; alt=&quot;Spring体系结构&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="study" scheme="http://yoursite.com/categories/study/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
</feed>
